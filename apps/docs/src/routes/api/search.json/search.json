[{"title":"Getting Started","href":"/docs/getting-started","description":"A quick guide to get started using tmcp","content":"import { Steps, Step, Callout, Card } from \"@svecodocs/kit\";  import PackageManagers from \"$lib/components/package-managers.svelte\";  import Select from \"$lib/components/select.svelte\";  import ArrowRight from \"phosphor-svelte/lib/ArrowRight\";   You have two ways to setup your project with tmcp to start building your MCP server:  Using the cli   Run the CLI   {#snippet pnpm()}  pnpm create tmcp  {/snippet} {#snippet npm()}  npm init tmcp  {/snippet} {#snippet yarn()}  yarn create tmcp  {/snippet}  {#snippet bun()}  bun create tmcp  {/snippet}  Follow the wizard ðŸ§™ðŸ»  The wizard will guide you towards the creation of a tmcp project. It will ask you for where do you want to create your project, which JSON schema adapter you want to use, which transport you want to use and if you want to include helpers to authenticate your MCP servers.  It will also ask you if you want to have an example MCP server that will create a file with the minimal boilerplate (using srvx in case you are building an HTTP server).  â”Œ  ðŸš€ Welcome to create-tmcp! â”‚ â—‡  Where should we create your TMCP project? â”‚  my-awesome-mcp â”‚ â—‡  Which schema adapter would you like to use? â”‚  Valibot (Recommended) â”‚ â—‡  Which transports would you like to include? â”‚  STDIO, HTTP â”‚ â—‡  Would you like to include OAuth 2.1 authentication? â”‚  Yes â”‚ â—‡  Would you like to include an example MCP server? â”‚  Yes â”‚ â—‡  Where should we place the example server? â”‚  src/index.js â”‚ â—‡  Would you like to automatically install dependencies? â”‚  Yes â”‚ â—‡  Which package manager would you like to use? â”‚  pnpm (Recommended) â”‚ â—‡  Project created successfully! â”‚ â—‡  Next steps: â”€â”€â”€â”€â”€â”€â”€â•® â”‚                     â”‚ â”‚  cd my-awesome-mcp  â”‚ â”‚  pnpm run dev       â”‚ â”‚                     â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚ â””  Happy coding! ðŸŽ‰  That's it  That's it, cd into your folder and start building your awesome mcp server!      The installer will create a package.json with the latest version of the required dependencies. If you want you can also run the boilerplate CLI in an existing project and it merge with your existing package.json.  Manual installation  tmcp is very composable: what this means is that each functionality it's separated in it's own package so you only get the bare minimum dependencies depending on what you are building.  So to setup a project manually you need to follow some steps:   Install tmcp   {#snippet pnpm()}  pnpm add tmcp  {/snippet} {#snippet npm()}  npm i tmcp  {/snippet} {#snippet yarn()}  yarn add tmcp  {/snippet}  {#snippet bun()}  bun add tmcp  {/snippet}   Choose a validation library  There are several adapters to convert from your validation library to JSON schema (the required format for the MCP protocol):  Valibot Zod (v3 and v4) Arktype Effect  once you have picked your dependency install the validation library AND the relative tmcp adapter   {#snippet children(adapter)}  {#if adapter === \"valibot\"}   {#snippet pnpm()}  pnpm add valibot @tmcp/adapter-valibot  {/snippet} {#snippet npm()}  npm i valibot @tmcp/adapter-valibot  {/snippet} {#snippet yarn()}  yarn add valibot @tmcp/adapter-valibot  {/snippet}  {#snippet bun()}  bun add valibot @tmcp/adapter-valibot  {/snippet}   {:else if adapter === \"zod\"}   {#snippet pnpm()}  pnpm add zod @tmcp/adapter-zod  {/snippet} {#snippet npm()}  npm i zod @tmcp/adapter-zod  {/snippet} {#snippet yarn()}  yarn add zod @tmcp/adapter-zod  {/snippet}  {#snippet bun()}  bun add zod @tmcp/adapter-zod  {/snippet}   {:else if adapter === \"zod (v3)\"}   {#snippet pnpm()}  pnpm add zod @tmcp/adapter-zod-v3  {/snippet} {#snippet npm()}  npm i zod @tmcp/adapter-zod-v3  {/snippet} {#snippet yarn()}  yarn add zod @tmcp/adapter-zod-v3  {/snippet}  {#snippet bun()}  bun add zod @tmcp/adapter-zod-v3  {/snippet}   {:else if adapter === \"arktype\"}   {#snippet pnpm()}  pnpm add arktype @tmcp/adapter-arktype  {/snippet} {#snippet npm()}  npm i arktype @tmcp/adapter-arktype  {/snippet} {#snippet yarn()}  yarn add arktype @tmcp/adapter-arktype  {/snippet}  {#snippet bun()}  bun add arktype @tmcp/adapter-arktype  {/snippet}   {:else}   {#snippet pnpm()}  pnpm add effect-ts @tmcp/adapter-effect  {/snippet} {#snippet npm()}  npm i effect-ts @tmcp/adapter-effect  {/snippet} {#snippet yarn()}  yarn add effect-ts @tmcp/adapter-effect  {/snippet}  {#snippet bun()}  bun add effect-ts @tmcp/adapter-effect  {/snippet}   {/if}  {/snippet}    Pick your transport  The core tmcp library is just a JSON-rpc server...to communicate you need to install an adapter. You can pick between three different adapters  STDIO**: used to build local servers that can be published on npm and communicate over stdin and stdout HTTP**: used to build remote servers. You can deploy them anywhere node/bun/deno run and use Streamable HTTP to communicate with your MCP client. SSE**: also used to build remote servers. This transport is officially deprecated in the MCP spec so you should default to HTTP if possible.    {#snippet children(transport)}  {#if transport === \"STDIO\"}   {#snippet pnpm()}  pnpm add @tmcp/transport-stdio  {/snippet} {#snippet npm()}  npm i @tmcp/transport-stdio  {/snippet} {#snippet yarn()}  yarn add @tmcp/transport-stdio  {/snippet}  {#snippet bun()}  bun add @tmcp/transport-stdio  {/snippet}   {:else if transport === \"HTTP\"}   {#snippet pnpm()}  pnpm add @tmcp/transport-http  {/snippet} {#snippet npm()}  npm i @tmcp/transport-http  {/snippet} {#snippet yarn()}  yarn add @tmcp/transport-http  {/snippet}  {#snippet bun()}  bun add @tmcp/transport-http  {/snippet}   {:else if transport === \"SSE\"}   {#snippet pnpm()}  pnpm add @tmcp/transport-sse  {/snippet} {#snippet npm()}  npm i @tmcp/transport-sse  {/snippet} {#snippet yarn()}  yarn add @tmcp/transport-sse  {/snippet}  {#snippet bun()}  bun add @tmcp/transport-sse  {/snippet}   {/if}  {/snippet}    (Optional) Install the Auth helper  If you plan to use authentication for your MCP server tmcp you will need to act as an Authorization server. This can be challenging and that's why tmcpÂ ships with a package dedicated to authentication. You can install it like this   {#snippet pnpm()}  pnpm add @tmcp/auth  {/snippet} {#snippet npm()}  npm i @tmcp/auth  {/snippet} {#snippet yarn()}  yarn add @tmcp/auth  {/snippet}  {#snippet bun()}  bun add @tmcp/auth  {/snippet}   And use it in your transport.   You can learn more about how to use the authentication helpers in the section dedicated to it.   (Optional) Install the Session manager helper  Building a remote MCP server at scale means either serverless or a distributed environment and that doesn't go well with the in-memory default behaviour of MCP servers. To ease that experience tmcpÂ provides a session manager abstraction that solves two problems:  when sending back notifications from the server (or if you are using the SSE transport) the handle of the SSE stream could be in a different server than the one receiving the POST request that triggers it all the information about the current MCP client (like client capabilities, client info, resources subscriptions) are stored in a different server than the one receiving the current POST request.  A session manager exports two classes that uses an external system (redis, postgres, cloudflare durable objects) to store this information and as a pub/sub dispatcher. Pick your player, install it like this:    {#snippet children(session_manager)}  {#if session_manager === \"Redis\"}   {#snippet pnpm()}  pnpm add @tmcp/session-manager-redis  {/snippet} {#snippet npm()}  npm i @tmcp/session-manager-redis  {/snippet} {#snippet yarn()}  yarn add @tmcp/session-manager-redis  {/snippet}  {#snippet bun()}  bun add @tmcp/session-manager-redis  {/snippet}   {:else if session_manager === \"Postgres\"}   {#snippet pnpm()}  pnpm add @tmcp/session-manager-postgres  {/snippet} {#snippet npm()}  npm i @tmcp/session-manager-postgres  {/snippet} {#snippet yarn()}  yarn add @tmcp/session-manager-postgres  {/snippet}  {#snippet bun()}  bun add @tmcp/session-manager-postgres  {/snippet}   {:else if session_manager === \"Cloudflare KV/Durable Objects\"}   {#snippet pnpm()}  pnpm add @tmcp/session-manager-durable-objects  {/snippet} {#snippet npm()}  npm i @tmcp/session-manager-durable-objects  {/snippet} {#snippet yarn()}  yarn add @tmcp/session-manager-durable-objects  {/snippet}  {#snippet bun()}  bun add @tmcp/session-manager-durable-objects  {/snippet}   {/if}  {/snippet}    And use it in your transport.   You can learn more about how to use a session manager in the section dedicated to it."},{"title":"Introduction","href":"/docs/index","description":"What and why is tmcp a thing?","content":"If you are ever come close to the world of Agentic AI I'm sure you've come across a certain acronym: MCP.  MCP: Model Context Protocol  As the name suggest Model Context Protocol is...well...a Protocol. Just like HTTP allow browsers (HTTP client) to communicate back and forth with our servers (HTTP server), MCP allows MCP clients to communicate back and forth with MCP servers. To do what? To allow LLMs (the Model in the acronym) to get additional Context (the Context in the acronym) and act on behalf of the user!  The MCP is a way to standardize the communication method between those clients (claude-code, codex, copilot etc) and the servers (what you are probably here to build).  The initiative was launched by Anthropic and quickly gained popularity and now has thousands of users.  If you are interested $2 but you are here to learn about tmcp so...  tmcp a modern way to build MCP servers  Most modern platform nowadays standardized on the fetch API to handle their requests/responses. SvelteKit, Next.js, SolidStart, Bun, Cloudflare Workers, Deno, they all handle HTTP calls in the same way: you expose a function that receives a Request instance and return a Response instance from it.  Simple, performant, modern.  There's also a lot of validation libraries out there: $2, $2, $2 each with it's own strength and as a library author you don't have to pick your favorite: you can use $2 to allow your users to pick their favorite!  This and much more were the reasons that moved us to build tmcp: a simple, composable, modern and flexible SDK to build your MCP server where YOU get to pick your deployment target, you validation library and your preferred transport without all the rest coming as a baggage!  But enough blabblering...you want to see the code!"},{"title":"OAuth","href":"/docs/auth/oauth","description":"Learn how to setup OAuth for your MCP server using the OAuth helper from `@tmcp/auth`","content":"Puppa"},{"title":"SimpleProvider","href":"/docs/auth/simple-provider","description":"Learn how to setup OAuth for your MCP server using the SimpleProvider helper from `@tmcp/auth`","content":"Puppa"},{"title":"McpServer","href":"/docs/core/mcp-server","description":"The main McpServer class","content":"import { Callout, Card } from \"@svecodocs/kit\";  import PackageManagers from \"$lib/components/package-managers.svelte\";  import Select from \"$lib/components/select.svelte\";   This is the instance that controls the logic behind your MCP server. You will use this instance to register your tool/resource/prompts, to send notifications, to read the context etc.  At his heart this class is basically a JSON-rpc server and you can use the method $2 to handle JSON-rpc payloads.  Initialization  McpServer is a class that you can instantiate with the information of your server (mainly name and version) and your capabilities:  const server = new McpServer(  {   name: 'a-super-basic-server',   version: '1.0.0',  },  {   adapter: undefined,   capabilities: {},  }, );  this will give you a very basic server that can only respond to ping requests and initialize requests. You can enhance your capabilities by specifying them in the capabilities object:  const server = new McpServer(  {   name: 'my-awesome-server',   version: '1.0.0',  },  {   adapter: undefined,   capabilities: {    tools: {     listChanged: true,    },    resources: {     subscribe: true,     listChanged: true,    },    prompts: {     listChanged: true,    },    logging: {},    completions: {},   },  }, );   If you don't include a capability registering a tool/resource/prompt will not automatically include that capability and the server will not respond to that method invocation.   You might notice something unusual in both of this code snippets: we are explicitly setting the adapter to undefined. The adapter is required to receive any kind of input or to send elicitation requests so, unless you are planning only to add tools that don't receive any input you should actually specify an adapter. As a nicety and for quick prototyping you can omit the adapter but you will get errors as soon as you try to define a schema for a tool so that's why you need to specifically pass undefined.  But we are not prototyping here so...  Specifying an adapter  The official MCP spec requires the server to send back the information about the input of a tool/prompt (or the requested schema of an elicitation request) in JSON-schema. While very powerful JSON-schema is also very verbose and very often developers already have a validation library installed in their project.  Thanks to $2 you can use every library that supports standard schema with tmcp. However we still need a way to convert from your validation library of choice to JSON-schema and that could be as simple as doing schema.toJSONSchema() in zod version 4 or as complex as finding and installing a separate library to do it for you (like zod v3 or valibot).  Introducing, adapters.  We did most of the work for you for the most common validation libraries:  Valibot Zod V3 Zod V4 Arktype Effect  so if you are using one of these libraries you are golden: just run   {#snippet children(adapter)}  {#if adapter === \"valibot\"}   {#snippet pnpm()}  pnpm add valibot @tmcp/adapter-valibot  {/snippet} {#snippet npm()}  npm i valibot @tmcp/adapter-valibot  {/snippet} {#snippet yarn()}  yarn add valibot @tmcp/adapter-valibot  {/snippet}  {#snippet bun()}  bun add valibot @tmcp/adapter-valibot  {/snippet}   {:else if adapter === \"zod\"}   {#snippet pnpm()}  pnpm add zod @tmcp/adapter-zod  {/snippet} {#snippet npm()}  npm i zod @tmcp/adapter-zod  {/snippet} {#snippet yarn()}  yarn add zod @tmcp/adapter-zod  {/snippet}  {#snippet bun()}  bun add zod @tmcp/adapter-zod  {/snippet}   {:else if adapter === \"zod (v3)\"}   {#snippet pnpm()}  pnpm add zod @tmcp/adapter-zod-v3  {/snippet} {#snippet npm()}  npm i zod @tmcp/adapter-zod-v3  {/snippet} {#snippet yarn()}  yarn add zod @tmcp/adapter-zod-v3  {/snippet}  {#snippet bun()}  bun add zod @tmcp/adapter-zod-v3  {/snippet}   {:else if adapter === \"arktype\"}   {#snippet pnpm()}  pnpm add arktype @tmcp/adapter-arktype  {/snippet} {#snippet npm()}  npm i arktype @tmcp/adapter-arktype  {/snippet} {#snippet yarn()}  yarn add arktype @tmcp/adapter-arktype  {/snippet}  {#snippet bun()}  bun add arktype @tmcp/adapter-arktype  {/snippet}   {:else}   {#snippet pnpm()}  pnpm add effect-ts @tmcp/adapter-effect  {/snippet} {#snippet npm()}  npm i effect-ts @tmcp/adapter-effect  {/snippet} {#snippet yarn()}  yarn add effect-ts @tmcp/adapter-effect  {/snippet}  {#snippet bun()}  bun add effect-ts @tmcp/adapter-effect  {/snippet}   {/if}  {/snippet}    once you do that you'll find a named export with a descriptive name that you can instantiate and pass as adapter to your McpServer class.  import { ValibotJsonSchemaAdapter } from '@tmcp/adapter-valibot';  const server = new McpServer(  {   name: 'a-super-basic-server',   version: '1.0.0',  },  {   adapter: new ValibotJsonSchemaAdapter(),   capabilities: {},  }, );  Then you will be able to pass valibot schemas to your tools/prompts/elicitations.    What if my standard schema library is not one of those?  Don't worry!  Writing your own adapter is very simple (given that your library supports converting into JSON-schema...if that's not the case I have bad news ðŸ˜…).  tmcp alsoÂ exports a class named JsonSchemaAdapter, all you have to do is create a class extends that class and override the toJsonSchema method  import { JsonSchemaAdapter } from 'tmcp/adapter'; // every validation library exports their base type // which needs to be a StandardSchema compatible type import type { BaseSchemaType } from 'your-validation-library';  class MyCustomJsonSchemaAdapter extends JsonSchemaAdapter {  async toJsonSchema(schema: BaseSchemaType) {   // find a way to convert to json schema   return schema.toJsonSchema();  } }  That's it! Now you can use your library with tmcp...and if you feel it you can also $2 to tmcp to make this an officially supported library!  Server instructions  An optional property of the configuration object is instructions...you can fill this to instruct the LLM on how and when to use your server  const server = new McpServer(  {   name: 'my-awesome-server',   version: '1.0.0',  },  {   adapter: undefined,   capabilities: {    tools: {     listChanged: true,    },    resources: {     subscribe: true,     listChanged: true,    },    prompts: {     listChanged: true,    },    logging: {},    completions: {},   },   instructions:    'You can use the server to do the most awesome thing in the world',  }, );  Pagination options  The MCP spec allows servers to paginate the results of list calls so that if you have a lot of tools/resources/prompts you can send them in batches instead of returning a single list that could overflow the tokens limits of some agent. tmcp handle all of this for you automatically, you just need to specify the page size:  const server = new McpServer(  {   name: 'my-awesome-server',   version: '1.0.0',  },  {   adapter: undefined,   capabilities: {    tools: {     listChanged: true,    },    resources: {     subscribe: true,     listChanged: true,    },    prompts: {     listChanged: true,    },    logging: {},    completions: {},   },   pagination: {    prompts: {     size: 15,    },    tools: {     size: 15,    },    resources: {     size: 15,    },   },  }, );  Context  We are gonna explore how context work $2 but is worth mentioning here that after you create you McpServer instance you have a withContext utility that allows you to specify the type for the custom context you expect. This type flows through the transports and in the server.ctx getter so you can actually get intellisense about the context you defined. To specify a type you can do:  const server = new McpServer({...}).withContext(); `"},{"title":"refreshRoots","href":"/docs/core/refreshRoots","description":"Learn how to refresh the list of allowed workspace folders from the client","content":"receive"},{"title":"log","href":"/docs/core/log","description":"Learn how to refresh the list of allowed workspace folders from the client","content":"receive"},{"title":"progress","href":"/docs/core/progress","description":"Learn how to refresh the list of allowed workspace folders from the client","content":"receive"},{"title":"changed","href":"/docs/core/changed","description":"Learn how to refresh the list of allowed workspace folders from the client","content":"receive"},{"title":"receive","href":"/docs/core/receive","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"request","href":"/docs/core/request","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"tool","href":"/docs/core/tool","description":"The star of the MCP protocol...learn how to register a tool that can be called by your Agent.","content":"import { Callout, Card } from \"@svecodocs/kit\";   Tools are one of the main MCP primitive: each tool you add to your MCP server will be available from the tools/list call the MCP client does (generally at the beginning of a session) and provides to the LLM.  Once there the LLM will be able to invoke one of the available tool and the MCP client will, in turn, invoke a tools/call on the MCP server. This makes them a very powerful primitive that allows LLMs to get additional context but also to interact with the real world.    For illustration purpose we are not gonna use the $2 but you should definitely check them out as they would make the code much shorter.  Basic API  You can register a tool invoking the tool method on the server instance. The first argument is a configuration object and the second a handler that will be invoked whenever that tool is invoked by the MCP client.  server.tool(  {   name: 'your-tool',   description: 'A description for the LLM',   title: 'Your Tool',  },  () => {   return {    content: [     {      type: 'text',      text: \"Here's the result of the tool\",     },    ],   };  }, );  name and description are the only required properties (you can also specify a title for a human readable title but that's optional) of the configuration object. The return value of the handler must be an object with a content property which is an array of one or more contents (you can refer to the $2 to know the possible return values)  Accepting inputs  If you want more powerful tools however you can also accept some inputs. However to be able to accept an input you need to specify the schema of your expected input    If you didn't define an adapter in you $2 instance trying to pass a schema will fail with a type error.    If you defined your adapter accepting some input is as simple as passing the schema property  server.tool(  {   name: 'fun-number-fact',   description: 'Get a fun fact from a number',   title: 'Fun Number Fact',   schema: v.object({    input: v.number(),   }),  },  async ({ input }) => {   const fun_fact = await get_fun_number_fact(input);   return {    content: [     {      type: 'text',      text: fun_fact,     },    ],   };  }, );    The schema MUST be an object and you'll get a type error if it's not.  Structured output  Some MCP clients are also able to ingest structured output from a tool call to use the return value of a tool call programmatically (eg. code mode from $2 or $2).  Just like the inputs, since the output can potentially go over the wire, the protocol requires the developer to define a schema for it. To do so, define an outputSchema in the configuration object and return a structuredContent from the handler.    The spec requires you to ALSO return the structured content as JSON.stringify-ied text from one of the element of content    server.tool(  {   name: 'fun-number-fact',   description: 'Get a fun fact from a number',   title: 'Fun Number Fact',   schema: v.object({    input: v.number(),   }),   outputSchema: v.object({    fact: v.string(),   }),  },  async ({ input }) => {   const fun_fact = await get_fun_number_fact(input);   return {    content: [     {      type: 'text',      text: JSON.stringify({ fact: fun_fact }),     },    ],    structuredContent: { fact: fun_fact },   };  }, );    The output schema MUST be an object and you'll get a type error if it's not. Also once you define an outputSchema you MUST return the structuredContent from the handler (unless you are returning an error).  Error handling  Tools are a bit special when it comes to error handling. Since they are invoked by the LLM to give them the context about what the error is and how to recover from it the spec requires you to return an object containing isError: true instead of throwing. tmcp does that for you automatically in case the input does not validate with the provided schema or if the LLM tries to call a non existent tool but to give you maximum freedom it doesn't automatically catches errors for you.  So it's recommended to do your error handling like this  server.tool(  {   name: 'fun-number-fact',   description: 'Get a fun fact from a number',   title: 'Fun Number Fact',   schema: v.object({    input: v.number(),   }),   outputSchema: v.object({    fact: v.string(),   }),  },  async ({ input }) => {   try {    const fun_fact = await get_fun_number_fact(input);    return {     content: [      {       type: 'text',       text: JSON.stringify({ fact: fun_fact }),      },     ],     structuredContent: { fact: fun_fact },    };   } catch {    return {     isError: true,     content: [      {       type: 'text',       // be more descriptive than this for better results ðŸ˜…       text: 'Unable to get a fun number fact',      },     ],    };   }  }, );  enabled function  One pattern that is quite common in every software is having a different feature-set based on some flag or the status of some user. You could technically create a new instance of the McpServer for each request and conditionally add a tool but to facilitate the process tmcp exposes an enabled property on the configuration object. The property is a function that returns a boolean and, as you might have guessed, allows you to include a specific tool in the list of tools conditionally. Within the function you have access to the $2 so you can make decisions based on the client capabilities (for example turning off a tool that requires sampling if the client doesn't supports it), the client info (for example turning off a tool that is too long for codex to handle) or even just reading a feature flag in the db to do A/B testing or to allow your admin to turn on or off a tool without a re-deploy.  server.tool(  {   name: 'get-divine-comedy',   description: 'Get the whole Divine Comedy',   enabled() {    return server.ctx.sessionInfo?.clientInfo?.name !== 'codex';   },  },  async () => {   return {    content: [     {      type: 'text',      text: 'Midway along the journey of our life I woke to find myself in a dark wood, for I had wandered off from the straight path...',     },    ],   };  }, );  Icons  To allow the users to to understand what an MCP server is about at a glance the MCP spec allows you to include a set of icons for each tool. Obviously tmcp allows you to specify those too using the icons property of the configuration object.    MCP clients are usually very strict about which icons they do or don't display. If your server is remote they'll only display remote icons served by the same domain or data images, if it's local they'll only display local files or data images. We suggest to include more icons and to properly test them with various clients.    server.tool(  {   name: 'get-divine-comedy',   description: 'Get the whole Divine Comedy',   icons: [    {     src: 'https://dantemcp.com/date.png',    },    {     src: 'data:image/png;base64,...',    },   ],  },  async () => {   return {    content: [     {      type: 'text',      text: 'Midway along the journey of our life I woke to find myself in a dark wood, for I had wandered off from the straight path...',     },    ],   };  }, );  Hints  The MCP spec also allows tool to specify additional hints and metadata that can be used by the LLM to determine how safe is it to call it. There are currently five possible annotations  title**: A second way to specify a human readable title for the tool (it's in the spec, don't ask why) destructiveHint**: Wether the tool will destroy some resource or not, signaling to the LLM that the tool should be called with caution idempotentHint**: wether the result of the tool would always be the same given the same inputs, signaling the LLM that it doesn't need to call it again if it was already called previously with the same arguments openWorldHint**: wether it would change something in the open world, like doing an api call to order a pizza readOnlyHint**: if it's a read only tool that will never write to a resource of any kind, signaling to the LLM that can call with less caution  You can specify those with the annotations property of the configuration object.  server.tool(  {   // rest of the tool   annotations: {    title: '',    destructiveHint: true,    idempotentHint: true,    openWorldHint: true,    readOnlyHint: true,   },  },  () => {   // handler  }, ); `"},{"title":"resource","href":"/docs/core/resource","description":"Learn how to register a new resource for your MCP server.","content":"import { Callout } from \"@svecodocs/kit\";   Resources are an, often overlooked, primitive of the MCP spec. You can think of them more or less as files that your MCP server can expose (in fact most MCP clients allow you to add them to the context with the same user interaction).  Differently from $2 the LLM is only involved as a recipient of resources and doesn't autonomously pick them. Instead the user has to select the resources that it wish to include in the message which will then be sent as additional context for the LLM.    For illustration purpose we are not gonna use the $2 but you should definitely check them out as they would make the code much shorter.  Basic API  You can register a resource by invoking the resource method on the server instance. The first argument is a configuration object and the second a handler that will be invoked whenever that resource is read by the MCP client.  server.resource(  {   uri: 'mymcp://name-of-the-resource.json',   name: 'your-resource',   description: 'A description for the LLM',   title: 'Your Resource',  },  (uri) => {   return {    contents: [     {      uri,      text: 'Content of the resource',      mimeType: 'text/plain', // this is optional     },    ],   };  }, );  uri, name and description are the only required properties (you can also specify a title for a human readable title but that's optional) of the configuration object. The return value of the handler must be an object with a contents property which is an array of one or more contents (you can refer to the $2 to know the possible return values).  The uri must conform to the $2 standard and it can be wether a common uri (like https or git) or it could be a custom one.  enabled function  One pattern that is quite common in every software is having a different feature-set based on some flag or the status of some user. You could technically create a new instance of the McpServer for each request and conditionally add a resource but to facilitate the process tmcp exposes an enabled property on the configuration object. The property is a function that returns a boolean and, as you might have guessed, allows you to include a specific resource in the list of resources conditionally. Within the function you have access to the $2 so you can make decisions based on the client capabilities, the client info or even just reading a feature flag in the db to do A/B testing or to allow your admin to turn on or off a resource without a re-deploy.  server.resource(  {   uri: 'mymcp://name-of-the-resource.json',   name: 'your-resource',   description: 'A description for the LLM',   title: 'Your Resource',   enabled() {    return server.ctx.sessionInfo?.clientInfo?.name !== 'codex';   },  },  (uri) => {   return {    contents: [     {      uri,      text: 'Content of the resource',      mimeType: 'text/plain', // this is optional     },    ],   };  }, );  Icons  To allow the users to to understand what an MCP server is about at a glance the MCP spec allows you to include a set of icons for each resource. Obviously tmcp allows you to specify those too using the icons property of the configuration object.    MCP clients are usually very strict about which icons they do or don't display. If your server is remote they'll only display remote icons served by the same domain or data images, if it's local they'll only display local files or data images. We suggest to include more icons and to properly test them with various clients.    server.resource(  {   uri: 'mymcp://name-of-the-resource.json',   name: 'your-resource',   description: 'A description for the LLM',   title: 'Your Resource',   icons: [    {     src: 'https://dantemcp.com/date.png',    },    {     src: 'data:image/png;base64,...',    },   ],  },  (uri) => {   return {    contents: [     {      uri,      text: 'Content of the resource',      mimeType: 'text/plain', // this is optional     },    ],   };  }, );  Dynamic Resources  The resource method is only used to add static resources to your MCP server, to learn how to add dynamic resources please check out the $2 documentation."},{"title":"template","href":"/docs/core/template","description":"Learn how to register a new dynamic resource for your MCP server.","content":"import { Callout } from \"@svecodocs/kit\";   Templates are the dynamic relatives of $2. They are resources at their heart but allow you to specify dynamic parts of the uri (just like you would do with a /blog/{slug} in an HTTP server).  They follow the same user flow as resources so the LLM is only involved as a recipient of them and doesn't autonomously pick them. Instead the user has to select the dynamic resources that it wish to include in the message which will then be sent as additional context for the LLM.    For illustration purpose we are not gonna use the $2 but you should definitely check them out as they would make the code much shorter.  Basic API  You can register a template by invoking the template method on the server instance. The first argument is a configuration object and the second a handler that will be invoked whenever that resource is read by the MCP client.  server.template(  {   uri: 'mymcp://some-path/{name}.json',   name: 'your-resource',   description: 'A description for the LLM',   title: 'Your Resource',  },  (uri) => {   return {    contents: [     {      uri,      text: 'Content of the resource',      mimeType: 'text/plain', // this is optional     },    ],   };  }, );  uri, name and description are the only required properties (you can also specify a title for a human readable title but that's optional) of the configuration object. The return value of the handler must be an object with a contents property which is an array of one or more contents (you can refer to the $2 to know the possible return values).  The uri must conform to the $2 standard and it can be wether a common uri (like https or git) or it could be a custom one. The dynamic part must adhere to the $2 standard.  Read the dynamic parameters  enabled function  One pattern that is quite common in every software is having a different feature-set based on some flag or the status of some user. You could technically create a new instance of the McpServer for each request and conditionally add a resource but to facilitate the process tmcp exposes an enabled property on the configuration object. The property is a function that returns a boolean and, as you might have guessed, allows you to include a specific resource in the list of resources conditionally. Within the function you have access to the $2 so you can make decisions based on the client capabilities, the client info or even just reading a feature flag in the db to do A/B testing or to allow your admin to turn on or off a resource without a re-deploy.  server.resource(  {   uri: 'mymcp://name-of-the-resource.json',   name: 'your-resource',   description: 'A description for the LLM',   title: 'Your Resource',   enabled() {    return server.ctx.sessionInfo?.clientInfo?.name !== 'codex';   },  },  (uri) => {   return {    contents: [     {      uri,      text: 'Content of the resource',      mimeType: 'text/plain', // this is optional     },    ],   };  }, );  Icons  To allow the users to to understand what an MCP server is about at a glance the MCP spec allows you to include a set of icons for each resource. Obviously tmcp allows you to specify those too using the icons property of the configuration object.    MCP clients are usually very strict about which icons they do or don't display. If your server is remote they'll only display remote icons served by the same domain or data images, if it's local they'll only display local files or data images. We suggest to include more icons and to properly test them with various clients.    server.resource(  {   uri: 'mymcp://name-of-the-resource.json',   name: 'your-resource',   description: 'A description for the LLM',   title: 'Your Resource',   icons: [    {     src: 'https://dantemcp.com/date.png',    },    {     src: 'data:image/png;base64,...',    },   ],  },  (uri) => {   return {    contents: [     {      uri,      text: 'Content of the resource',      mimeType: 'text/plain', // this is optional     },    ],   };  }, );  Dynamic Resources  The resource method is only used to add static resources to your MCP server, to learn how to add dynamic resources please check out the $2 documentation."},{"title":"prompt","href":"/docs/core/prompt","description":"Learn how to register a new prompt for your MCP server.","content":"prompt"},{"title":"on","href":"/docs/core/on","description":"Learn how to register event listeners on the MCP server and which events are available.","content":"on"},{"title":"ctx","href":"/docs/core/ctx","description":"Learn everything about the context available on the server.","content":"ctx"},{"title":"elicitation","href":"/docs/core/elicitation","description":"Learn how to ask for more information from the MCP client","content":"receive"},{"title":"message","href":"/docs/core/message","description":"Learn how to request the user to use the LLM to do inference work","content":"receive"},{"title":"Redis","href":"/docs/session-managers/redis","description":"Learn how to run and deploy your server remotely everywhere JS runs.","content":"HTTP"},{"title":"Postgres","href":"/docs/session-managers/stdio","description":"Learn how to run and deploy your server remotely everywhere JS runs.","content":"HTTP"},{"title":"Durable Objects","href":"/docs/session-managers/sse","description":"Learn how to run and deploy your server remotely everywhere JS runs.","content":"HTTP"},{"title":"Overview","href":"/docs/session-managers/overview","description":"Learn how to run and deploy your server remotely everywhere JS runs.","content":""},{"title":"tool","href":"/docs/utils/tool","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"resource","href":"/docs/utils/resource","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"prompt","href":"/docs/utils/prompt","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"complete","href":"/docs/utils/complete","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"HTTP","href":"/docs/transports/http","description":"Learn how to run and deploy your server remotely everywhere JS runs.","content":"HTTP"},{"title":"STDIO","href":"/docs/transports/stdio","description":"Learn how to build an MCP server that runs locally.","content":"stdio"},{"title":"SSE","href":"/docs/transports/sse","description":"Learn how to run and deploy your server remotely everywhere JS runs using the deprecated SSE transport.","content":"SSE"}]