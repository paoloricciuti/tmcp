[{"title":"Getting Started","href":"/docs/getting-started","description":"A quick guide to get started using tmcp","content":"import { Steps, Step, Callout, Card } from \"@svecodocs/kit\";  import PackageManagers from \"$lib/components/package-managers.svelte\";  import Select from \"$lib/components/select.svelte\";  import ArrowRight from \"phosphor-svelte/lib/ArrowRight\";   You have two ways to setup your project with tmcp to start building your MCP server:  Using the cli   Run the CLI   {#snippet pnpm()}  pnpm create tmcp  {/snippet} {#snippet npm()}  npm init tmcp  {/snippet} {#snippet yarn()}  yarn create tmcp  {/snippet}  {#snippet bun()}  bun create tmcp  {/snippet}  Follow the wizard üßôüèª  The wizard will guide you towards the creation of a tmcp project. It will ask you for where do you want to create your project, which JSON schema adapter you want to use, which transport you want to use and if you want to include helpers to authenticate your MCP servers.  It will also ask you if you want to have an example MCP server that will create a file with the minimal boilerplate (using srvx in case you are building an HTTP server).  ‚îå  üöÄ Welcome to create-tmcp! ‚îÇ ‚óá  Where should we create your TMCP project? ‚îÇ  my-awesome-mcp ‚îÇ ‚óá  Which schema adapter would you like to use? ‚îÇ  Valibot (Recommended) ‚îÇ ‚óá  Which transports would you like to include? ‚îÇ  STDIO, HTTP ‚îÇ ‚óá  Would you like to include OAuth 2.1 authentication? ‚îÇ  Yes ‚îÇ ‚óá  Would you like to include an example MCP server? ‚îÇ  Yes ‚îÇ ‚óá  Where should we place the example server? ‚îÇ  src/index.js ‚îÇ ‚óá  Would you like to automatically install dependencies? ‚îÇ  Yes ‚îÇ ‚óá  Which package manager would you like to use? ‚îÇ  pnpm (Recommended) ‚îÇ ‚óá  Project created successfully! ‚îÇ ‚óá  Next steps: ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ ‚îÇ                     ‚îÇ ‚îÇ  cd my-awesome-mcp  ‚îÇ ‚îÇ  pnpm run dev       ‚îÇ ‚îÇ                     ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ ‚îÇ ‚îî  Happy coding! üéâ  That's it  That's it, cd into your folder and start building your awesome mcp server!      The installer will create a package.json with the latest version of the required dependencies. If you want you can also run the boilerplate CLI in an existing project and it merge with your existing package.json.  Manual installation  tmcp is very composable: what this means is that each functionality it's separated in it's own package so you only get the bare minimum dependencies depending on what you are building.  So to setup a project manually you need to follow some steps:   Install tmcp   {#snippet pnpm()}  pnpm add tmcp  {/snippet} {#snippet npm()}  npm i tmcp  {/snippet} {#snippet yarn()}  yarn add tmcp  {/snippet}  {#snippet bun()}  bun add tmcp  {/snippet}   Choose a validation library  There are several adapters to convert from your validation library to JSON schema (the required format for the MCP protocol):  Valibot Zod (v3 and v4) Arktype Effect  once you have picked your dependency install the validation library AND the relative tmcp adapter   {#snippet children(adapter)}  {#if adapter === \"valibot\"}   {#snippet pnpm()}  pnpm add valibot @tmcp/adapter-valibot  {/snippet} {#snippet npm()}  npm i valibot @tmcp/adapter-valibot  {/snippet} {#snippet yarn()}  yarn add valibot @tmcp/adapter-valibot  {/snippet}  {#snippet bun()}  bun add valibot @tmcp/adapter-valibot  {/snippet}   {:else if adapter === \"zod\"}   {#snippet pnpm()}  pnpm add zod @tmcp/adapter-zod  {/snippet} {#snippet npm()}  npm i zod @tmcp/adapter-zod  {/snippet} {#snippet yarn()}  yarn add zod @tmcp/adapter-zod  {/snippet}  {#snippet bun()}  bun add zod @tmcp/adapter-zod  {/snippet}   {:else if adapter === \"zod (v3)\"}   {#snippet pnpm()}  pnpm add zod @tmcp/adapter-zod-v3  {/snippet} {#snippet npm()}  npm i zod @tmcp/adapter-zod-v3  {/snippet} {#snippet yarn()}  yarn add zod @tmcp/adapter-zod-v3  {/snippet}  {#snippet bun()}  bun add zod @tmcp/adapter-zod-v3  {/snippet}   {:else if adapter === \"arktype\"}   {#snippet pnpm()}  pnpm add arktype @tmcp/adapter-arktype  {/snippet} {#snippet npm()}  npm i arktype @tmcp/adapter-arktype  {/snippet} {#snippet yarn()}  yarn add arktype @tmcp/adapter-arktype  {/snippet}  {#snippet bun()}  bun add arktype @tmcp/adapter-arktype  {/snippet}   {:else}   {#snippet pnpm()}  pnpm add effect-ts @tmcp/adapter-effect  {/snippet} {#snippet npm()}  npm i effect-ts @tmcp/adapter-effect  {/snippet} {#snippet yarn()}  yarn add effect-ts @tmcp/adapter-effect  {/snippet}  {#snippet bun()}  bun add effect-ts @tmcp/adapter-effect  {/snippet}   {/if}  {/snippet}    Pick your transport  The core tmcp library is just a JSON-rpc server...to communicate you need to install an adapter. You can pick between three different adapters  STDIO**: used to build local servers that can be published on npm and communicate over stdin and stdout HTTP**: used to build remote servers. You can deploy them anywhere node/bun/deno run and use Streamable HTTP to communicate with your MCP client. SSE**: also used to build remote servers. This transport is officially deprecated in the MCP spec so you should default to HTTP if possible.    {#snippet children(transport)}  {#if transport === \"STDIO\"}   {#snippet pnpm()}  pnpm add @tmcp/transport-stdio  {/snippet} {#snippet npm()}  npm i @tmcp/transport-stdio  {/snippet} {#snippet yarn()}  yarn add @tmcp/transport-stdio  {/snippet}  {#snippet bun()}  bun add @tmcp/transport-stdio  {/snippet}   {:else if transport === \"HTTP\"}   {#snippet pnpm()}  pnpm add @tmcp/transport-http  {/snippet} {#snippet npm()}  npm i @tmcp/transport-http  {/snippet} {#snippet yarn()}  yarn add @tmcp/transport-http  {/snippet}  {#snippet bun()}  bun add @tmcp/transport-http  {/snippet}   {:else if transport === \"SSE\"}   {#snippet pnpm()}  pnpm add @tmcp/transport-sse  {/snippet} {#snippet npm()}  npm i @tmcp/transport-sse  {/snippet} {#snippet yarn()}  yarn add @tmcp/transport-sse  {/snippet}  {#snippet bun()}  bun add @tmcp/transport-sse  {/snippet}   {/if}  {/snippet}    (Optional) Install the Auth helper  If you plan to use authentication for your MCP server tmcp you will need to act as an Authorization server. This can be challenging and that's why tmcp¬†ships with a package dedicated to authentication. You can install it like this   {#snippet pnpm()}  pnpm add @tmcp/auth  {/snippet} {#snippet npm()}  npm i @tmcp/auth  {/snippet} {#snippet yarn()}  yarn add @tmcp/auth  {/snippet}  {#snippet bun()}  bun add @tmcp/auth  {/snippet}   And use it in your transport.   You can learn more about how to use the authentication helpers in the section dedicated to it.   (Optional) Install the Session manager helper  Building a remote MCP server at scale means either serverless or a distributed environment and that doesn't go well with the in-memory default behaviour of MCP servers. To ease that experience tmcp¬†provides a session manager abstraction that solves two problems:  when sending back notifications from the server (or if you are using the SSE transport) the handle of the SSE stream could be in a different server than the one receiving the POST request that triggers it all the information about the current MCP client (like client capabilities, client info, resources subscriptions) are stored in a different server than the one receiving the current POST request.  A session manager exports two classes that uses an external system (redis, postgres, cloudflare durable objects) to store this information and as a pub/sub dispatcher. Pick your player, install it like this:    {#snippet children(session_manager)}  {#if session_manager === \"Redis\"}   {#snippet pnpm()}  pnpm add @tmcp/session-manager-redis  {/snippet} {#snippet npm()}  npm i @tmcp/session-manager-redis  {/snippet} {#snippet yarn()}  yarn add @tmcp/session-manager-redis  {/snippet}  {#snippet bun()}  bun add @tmcp/session-manager-redis  {/snippet}   {:else if session_manager === \"Postgres\"}   {#snippet pnpm()}  pnpm add @tmcp/session-manager-postgres  {/snippet} {#snippet npm()}  npm i @tmcp/session-manager-postgres  {/snippet} {#snippet yarn()}  yarn add @tmcp/session-manager-postgres  {/snippet}  {#snippet bun()}  bun add @tmcp/session-manager-postgres  {/snippet}   {:else if session_manager === \"Cloudflare KV/Durable Objects\"}   {#snippet pnpm()}  pnpm add @tmcp/session-manager-durable-objects  {/snippet} {#snippet npm()}  npm i @tmcp/session-manager-durable-objects  {/snippet} {#snippet yarn()}  yarn add @tmcp/session-manager-durable-objects  {/snippet}  {#snippet bun()}  bun add @tmcp/session-manager-durable-objects  {/snippet}   {/if}  {/snippet}    And use it in your transport.   You can learn more about how to use a session manager in the section dedicated to it."},{"title":"Introduction","href":"/docs/index","description":"What and why is tmcp a thing?","content":"If you are ever come close to the world of Agentic AI I'm sure you've come across a certain acronym: MCP.  MCP: Model Context Protocol  As the name suggest Model Context Protocol is...well...a Protocol. Just like HTTP allow browsers (HTTP client) to communicate back and forth with our servers (HTTP server), MCP allows MCP clients to communicate back and forth with MCP servers. To do what? To allow LLMs (the Model in the acronym) to get additional Context (the Context in the acronym) and act on behalf of the user!  The MCP is a way to standardize the communication method between those clients (claude-code, codex, copilot etc) and the servers (what you are probably here to build).  The initiative was launched by Anthropic and quickly gained popularity and now has thousands of users.  If you are interested $2 but you are here to learn about tmcp so...  tmcp a modern way to build MCP servers  Most modern platform nowadays standardized on the fetch API to handle their requests/responses. SvelteKit, Next.js, SolidStart, Bun, Cloudflare Workers, Deno, they all handle HTTP calls in the same way: you expose a function that receives a Request instance and return a Response instance from it.  Simple, performant, modern.  There's also a lot of validation libraries out there: $2, $2, $2 each with it's own strength and as a library author you don't have to pick your favorite: you can use $2 to allow your users to pick their favorite!  This and much more were the reasons that moved us to build tmcp: a simple, composable, modern and flexible SDK to build your MCP server where YOU get to pick your deployment target, you validation library and your preferred transport without all the rest coming as a baggage!  But enough blabblering...you want to see the code!"},{"title":"OAuth","href":"/docs/auth/oauth","description":"Learn how to setup OAuth for your MCP server using the OAuth helper from `@tmcp/auth`","content":"Puppa"},{"title":"SimpleProvider","href":"/docs/auth/simple-provider","description":"Learn how to setup OAuth for your MCP server using the SimpleProvider helper from `@tmcp/auth`","content":"Puppa"},{"title":"McpServer","href":"/docs/core/mcp-server","description":"The main McpServer class","content":"import { Callout, Card } from \"@svecodocs/kit\";  import PackageManagers from \"$lib/components/package-managers.svelte\";  import Select from \"$lib/components/select.svelte\";   This is the instance that controls the logic behind your MCP server. You will use this instance to register your tool/resource/prompts, to send notifications, to read the context etc.  At his heart this class is basically a JSON-rpc server and you can use the method $2 to handle JSON-rpc payloads.  Initialization  McpServer is a class that you can instantiate with the information of your server (mainly name and version) and your capabilities:  const server = new McpServer(  {   name: 'a-super-basic-server',   version: '1.0.0',  },  {   adapter: undefined,   capabilities: {},  }, );  this will give you a very basic server that can only respond to ping requests and initialize requests. You can enhance your capabilities by specifying them in the capabilities object:  const server = new McpServer(  {   name: 'my-awesome-server',   version: '1.0.0',  },  {   adapter: undefined,   capabilities: {    tools: {     listChanged: true,    },    resources: {     subscribe: true,     listChanged: true,    },    prompts: {     listChanged: true,    },    logging: {},    completions: {},   },  }, );   If you don't include a capability registering a tool/resource/prompt will not automatically include that capability and the server will not respond to that method invocation.   You might notice something unusual in both of this code snippets: we are explicitly setting the adapter to undefined. The adapter is required to receive any kind of input or to send elicitation requests so, unless you are planning only to add tools that don't receive any input you should actually specify an adapter. As a nicety and for quick prototyping you can omit the adapter but you will get errors as soon as you try to define a schema for a tool so that's why you need to specifically pass undefined.  But we are not prototyping here so...  Specifying an adapter  The official MCP spec requires the server to send back the information about the input of a tool/prompt (or the requested schema of an elicitation request) in JSON-schema. While very powerful JSON-schema is also very verbose and very often developers already have a validation library installed in their project.  Thanks to $2 you can use every library that supports standard schema with tmcp. However we still need a way to convert from your validation library of choice to JSON-schema and that could be as simple as doing schema.toJSONSchema() in zod version 4 or as complex as finding and installing a separate library to do it for you (like zod v3 or valibot).  Introducing, adapters.  We did most of the work for you for the most common validation libraries:  Valibot Zod V3 Zod V4 Arktype Effect  so if you are using one of these libraries you are golden: just run   {#snippet children(adapter)}  {#if adapter === \"valibot\"}   {#snippet pnpm()}  pnpm add valibot @tmcp/adapter-valibot  {/snippet} {#snippet npm()}  npm i valibot @tmcp/adapter-valibot  {/snippet} {#snippet yarn()}  yarn add valibot @tmcp/adapter-valibot  {/snippet}  {#snippet bun()}  bun add valibot @tmcp/adapter-valibot  {/snippet}   {:else if adapter === \"zod\"}   {#snippet pnpm()}  pnpm add zod @tmcp/adapter-zod  {/snippet} {#snippet npm()}  npm i zod @tmcp/adapter-zod  {/snippet} {#snippet yarn()}  yarn add zod @tmcp/adapter-zod  {/snippet}  {#snippet bun()}  bun add zod @tmcp/adapter-zod  {/snippet}   {:else if adapter === \"zod (v3)\"}   {#snippet pnpm()}  pnpm add zod @tmcp/adapter-zod-v3  {/snippet} {#snippet npm()}  npm i zod @tmcp/adapter-zod-v3  {/snippet} {#snippet yarn()}  yarn add zod @tmcp/adapter-zod-v3  {/snippet}  {#snippet bun()}  bun add zod @tmcp/adapter-zod-v3  {/snippet}   {:else if adapter === \"arktype\"}   {#snippet pnpm()}  pnpm add arktype @tmcp/adapter-arktype  {/snippet} {#snippet npm()}  npm i arktype @tmcp/adapter-arktype  {/snippet} {#snippet yarn()}  yarn add arktype @tmcp/adapter-arktype  {/snippet}  {#snippet bun()}  bun add arktype @tmcp/adapter-arktype  {/snippet}   {:else}   {#snippet pnpm()}  pnpm add effect-ts @tmcp/adapter-effect  {/snippet} {#snippet npm()}  npm i effect-ts @tmcp/adapter-effect  {/snippet} {#snippet yarn()}  yarn add effect-ts @tmcp/adapter-effect  {/snippet}  {#snippet bun()}  bun add effect-ts @tmcp/adapter-effect  {/snippet}   {/if}  {/snippet}    once you do that you'll find a named export with a descriptive name that you can instantiate and pass as adapter to your McpServer class.  import { ValibotJsonSchemaAdapter } from '@tmcp/adapter-valibot';  const server = new McpServer(  {   name: 'a-super-basic-server',   version: '1.0.0',  },  {   adapter: new ValibotJsonSchemaAdapter(),   capabilities: {},  }, );  Then you will be able to pass valibot schemas to your tools/prompts/elicitations.    What if my standard schema library is not one of those?  Don't worry!  Writing your own adapter is very simple (given that your library supports converting into JSON-schema...if that's not the case I have bad news üòÖ).  tmcp also¬†exports a class named JsonSchemaAdapter, all you have to do is create a class extends that class and override the toJsonSchema method  import { JsonSchemaAdapter } from 'tmcp/adapter'; // every validation library exports their base type // which needs to be a StandardSchema compatible type import type { BaseSchemaType } from 'your-validation-library';  class MyCustomJsonSchemaAdapter extends JsonSchemaAdapter {  async toJsonSchema(schema: BaseSchemaType) {   // find a way to convert to json schema   return schema.toJsonSchema();  } }  That's it! Now you can use your library with tmcp...and if you feel it you can also $2 to tmcp to make this an officially supported library!  Server instructions  An optional property of the configuration object is instructions...you can fill this to instruct the LLM on how and when to use your server  const server = new McpServer(  {   name: 'my-awesome-server',   version: '1.0.0',  },  {   adapter: undefined,   capabilities: {    tools: {     listChanged: true,    },    resources: {     subscribe: true,     listChanged: true,    },    prompts: {     listChanged: true,    },    logging: {},    completions: {},   },   instructions:    'You can use the server to do the most awesome thing in the world',  }, );  Pagination options  The MCP spec allows servers to paginate the results of list calls so that if you have a lot of tools/resources/prompts you can send them in batches instead of returning a single list that could overflow the tokens limits of some agent. tmcp handle all of this for you automatically, you just need to specify the page size:  const server = new McpServer(  {   name: 'my-awesome-server',   version: '1.0.0',  },  {   adapter: undefined,   capabilities: {    tools: {     listChanged: true,    },    resources: {     subscribe: true,     listChanged: true,    },    prompts: {     listChanged: true,    },    logging: {},    completions: {},   },   pagination: {    prompts: {     size: 15,    },    tools: {     size: 15,    },    resources: {     size: 15,    },   },  }, );  Context  We are gonna explore how context work $2 but is worth mentioning here that after you create you McpServer instance you have a withContext utility that allows you to specify the type for the custom context you expect. This type flows through the transports and in the server.ctx getter so you can actually get intellisense about the context you defined. To specify a type you can do:  const server = new McpServer({...}).withContext(); `"},{"title":"refreshRoots","href":"/docs/core/refreshRoots","description":"Learn how to refresh the list of allowed workspace folders from the client","content":"receive"},{"title":"log","href":"/docs/core/log","description":"Learn how to refresh the list of allowed workspace folders from the client","content":"receive"},{"title":"progress","href":"/docs/core/progress","description":"Learn how to refresh the list of allowed workspace folders from the client","content":"receive"},{"title":"changed","href":"/docs/core/changed","description":"Learn how to refresh the list of allowed workspace folders from the client","content":"receive"},{"title":"receive","href":"/docs/core/receive","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"request","href":"/docs/core/request","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"tool","href":"/docs/core/tool","description":"The start of the MCP protocol...learn how to register a tool that can be called by your Agent.","content":"tool"},{"title":"resource","href":"/docs/core/resource","description":"Learn how to register a new resource for your MCP server.","content":"resource"},{"title":"template","href":"/docs/core/template","description":"Learn how to register a new dynamic resource for your MCP server.","content":"template"},{"title":"prompt","href":"/docs/core/prompt","description":"Learn how to register a new prompt for your MCP server.","content":"prompt"},{"title":"on","href":"/docs/core/on","description":"Learn how to register event listeners on the MCP server and which events are available.","content":"on"},{"title":"ctx","href":"/docs/core/ctx","description":"Learn everything about the context available on the server.","content":"ctx"},{"title":"elicitation","href":"/docs/core/elicitation","description":"Learn how to ask for more information from the MCP client","content":"receive"},{"title":"message","href":"/docs/core/message","description":"Learn how to request the user to use the LLM to do inference work","content":"receive"},{"title":"HTTP","href":"/docs/transports/http","description":"Learn how to run and deploy your server remotely everywhere JS runs.","content":"HTTP"},{"title":"STDIO","href":"/docs/transports/stdio","description":"Learn how to build an MCP server that runs locally.","content":"stdio"},{"title":"SSE","href":"/docs/transports/sse","description":"Learn how to run and deploy your server remotely everywhere JS runs using the deprecated SSE transport.","content":"SSE"},{"title":"Redis","href":"/docs/session-managers/redis","description":"Learn how to run and deploy your server remotely everywhere JS runs.","content":"HTTP"},{"title":"Postgres","href":"/docs/session-managers/stdio","description":"Learn how to run and deploy your server remotely everywhere JS runs.","content":"HTTP"},{"title":"Durable Objects","href":"/docs/session-managers/sse","description":"Learn how to run and deploy your server remotely everywhere JS runs.","content":"HTTP"},{"title":"Overview","href":"/docs/session-managers/overview","description":"Learn how to run and deploy your server remotely everywhere JS runs.","content":""},{"title":"tool","href":"/docs/utils/tool","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"resource","href":"/docs/utils/resource","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"prompt","href":"/docs/utils/prompt","description":"The main entrypoint to your MCP server","content":"receive"},{"title":"complete","href":"/docs/utils/complete","description":"The main entrypoint to your MCP server","content":"receive"}]