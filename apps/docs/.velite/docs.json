[
  {
    "title": "Getting Started",
    "description": "A quick guide to get started using tmcp",
    "path": "000-getting-started",
    "content": "<script>\n\timport { Steps, Step, Callout, Card } from \"@svecodocs/kit\";\n\timport PackageManagers from \"$lib/components/package-managers.svelte\";\n\timport Select from \"$lib/components/select.svelte\";\n\timport ArrowRight from \"phosphor-svelte/lib/ArrowRight\";\n</script>\n<p>You have two ways to setup your project with <code>tmcp</code> to start building your MCP server:</p>\n<h2>Using the cli</h2>\n<steps>\n<step>Run the CLI</step>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm create tmcp\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm init tmcp\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn create tmcp\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun create tmcp\n</code></pre>\n<p>{/snippet}\n\n<step>Follow the wizard üßôüèª</step></p>\n<p>The wizard will guide you towards the creation of a <code>tmcp</code> project. It will ask you for where do you want to create your project, which JSON schema adapter you want to use, which transport you want to use and if you want to include helpers to authenticate your MCP servers.</p>\n<p>It will also ask you if you want to have an example MCP server that will create a file with the minimal boilerplate (using <code>srvx</code> in case you are building an HTTP server).</p>\n<pre><code class=\"language-bash\">‚îå  üöÄ Welcome to create-tmcp!\n‚îÇ\n‚óá  Where should we create your TMCP project?\n‚îÇ  my-awesome-mcp\n‚îÇ\n‚óá  Which schema adapter would you like to use?\n‚îÇ  Valibot (Recommended)\n‚îÇ\n‚óá  Which transports would you like to include?\n‚îÇ  STDIO, HTTP\n‚îÇ\n‚óá  Would you like to include OAuth 2.1 authentication?\n‚îÇ  Yes\n‚îÇ\n‚óá  Would you like to include an example MCP server?\n‚îÇ  Yes\n‚îÇ\n‚óá  Where should we place the example server?\n‚îÇ  src/index.js\n‚îÇ\n‚óá  Would you like to automatically install dependencies?\n‚îÇ  Yes\n‚îÇ\n‚óá  Which package manager would you like to use?\n‚îÇ  pnpm (Recommended)\n‚îÇ\n‚óá  Project created successfully!\n‚îÇ\n‚óá  Next steps: ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ                     ‚îÇ\n‚îÇ  cd my-awesome-mcp  ‚îÇ\n‚îÇ  pnpm run dev       ‚îÇ\n‚îÇ                     ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n‚îÇ\n‚îî  Happy coding! üéâ\n</code></pre>\n<p><step>That's it</step></p>\n<p>That's it, <code>cd</code> into your folder and start building your awesome mcp server!</p>\n</packagemanagers></steps>\n<callout type=\"tip\" title=\"Info\">\n<p>The installer will create a <code>package.json</code> with the latest version of the required dependencies. If you want you can also run the boilerplate CLI in an existing project and it merge with your existing <code>package.json</code>.</p>\n</callout>\n<h2>Manual installation</h2>\n<p><code>tmcp</code> is very composable: what this means is that each functionality it's separated in it's own package so you only get the bare minimum dependencies depending on what you are building.</p>\n<p>So to setup a project manually you need to follow some steps:</p>\n<steps>\n<step>Install `tmcp`</step>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add tmcp\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i tmcp\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add tmcp\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add tmcp\n</code></pre>\n<p>{/snippet}\n</p>\n<p><step>Choose a validation library</step></p>\n<p>There are several adapters to convert from your validation library to JSON schema (the required format for the MCP protocol):</p>\n<ul>\n<li>Valibot</li>\n<li>Zod (v3 and v4)</li>\n<li>Arktype</li>\n<li>Effect</li>\n</ul>\n<p>once you have picked your dependency install the validation library AND the relative <code>tmcp</code> adapter</p>\n<p>&#x3C;Select options={[\"valibot\", \"zod\", \"zod (v3)\", \"arktype\", \"effect\"]} title=\"Adapter\">\n{#snippet children(adapter)}</p>\n<p>{#if adapter === \"valibot\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add valibot @tmcp/adapter-valibot\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i valibot @tmcp/adapter-valibot\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add valibot @tmcp/adapter-valibot\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add valibot @tmcp/adapter-valibot\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else if adapter === \"zod\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add zod @tmcp/adapter-zod\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i zod @tmcp/adapter-zod\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add zod @tmcp/adapter-zod\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add zod @tmcp/adapter-zod\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else if adapter === \"zod (v3)\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add zod @tmcp/adapter-zod-v3\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i zod @tmcp/adapter-zod-v3\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add zod @tmcp/adapter-zod-v3\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add zod @tmcp/adapter-zod-v3\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else if adapter === \"arktype\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add arktype @tmcp/adapter-arktype\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i arktype @tmcp/adapter-arktype\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add arktype @tmcp/adapter-arktype\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add arktype @tmcp/adapter-arktype\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add effect-ts @tmcp/adapter-effect\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i effect-ts @tmcp/adapter-effect\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add effect-ts @tmcp/adapter-effect\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add effect-ts @tmcp/adapter-effect\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{/if}</p>\n<p>{/snippet}</p>\n\n<p><step>Pick your transport</step></p>\n<p>The core <code>tmcp</code> library is just a JSON-rpc server...to communicate you need to install an adapter. You can pick between three different adapters</p>\n<ul>\n<li><strong>STDIO</strong>: used to build local servers that can be published on <code>npm</code> and communicate over <code>stdin</code> and <code>stdout</code></li>\n<li><strong>HTTP</strong>: used to build remote servers. You can deploy them anywhere node/bun/deno run and use Streamable HTTP to communicate with your MCP client.</li>\n<li><strong>SSE</strong>: also used to build remote servers. This transport is officially deprecated in the MCP spec so you should default to HTTP if possible.</li>\n</ul>\n<p>&#x3C;Select options={[\"STDIO\", \"HTTP\", \"SSE\"]} title=\"Transport\"></p>\n<p>{#snippet children(transport)}</p>\n<p>{#if transport === \"STDIO\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add @tmcp/transport-stdio\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i @tmcp/transport-stdio\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add @tmcp/transport-stdio\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add @tmcp/transport-stdio\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else if transport === \"HTTP\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add @tmcp/transport-http\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i @tmcp/transport-http\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add @tmcp/transport-http\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add @tmcp/transport-http\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else if transport === \"SSE\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add @tmcp/transport-sse\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i @tmcp/transport-sse\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add @tmcp/transport-sse\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add @tmcp/transport-sse\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{/if}</p>\n<p>{/snippet}</p>\n\n<p><step>(Optional) Install the Auth helper</step></p>\n<p>If you plan to use authentication for your MCP server <code>tmcp</code> you will need to act as an <em>Authorization server</em>. This can be challenging and that's why <code>tmcp</code>¬†ships with a package dedicated to authentication. You can install it like this</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add @tmcp/auth\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i @tmcp/auth\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add @tmcp/auth\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add @tmcp/auth\n</code></pre>\n<p>{/snippet}\n</p>\n<p>And use it in your transport.</p>\n<card href=\"/docs/auth/oauth\" title=\"Learn how to use the authentication helpers\" icon=\"{ArrowRight}\" horizontal=\"\">\nYou can learn more about how to use the authentication helpers in the section dedicated to it.\n</card>\n<p><step>(Optional) Install the Session manager helper</step></p>\n<p>Building a remote MCP server at scale means either serverless or a distributed environment and that doesn't go well with the in-memory default behaviour of MCP servers. To ease that experience <code>tmcp</code>¬†provides a session manager abstraction that solves two problems:</p>\n<ol>\n<li>when sending back notifications from the server (or if you are using the SSE transport) the handle of the SSE stream could be in a different server than the one receiving the POST request that triggers it</li>\n<li>all the information about the current MCP client (like client capabilities, client info, resources subscriptions) are stored in a different server than the one receiving the current POST request.</li>\n</ol>\n<p>A session manager exports two classes that uses an external system (redis, postgres, cloudflare durable objects) to store this information and as a pub/sub dispatcher. Pick your player, install it like this:</p>\n<p>&#x3C;Select options={[\"Redis\", \"Postgres\", \"Cloudflare KV/Durable Objects\"]} title=\"Session Manager\"></p>\n<p>{#snippet children(session_manager)}</p>\n<p>{#if session_manager === \"Redis\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add @tmcp/session-manager-redis\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i @tmcp/session-manager-redis\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add @tmcp/session-manager-redis\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add @tmcp/session-manager-redis\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else if session_manager === \"Postgres\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add @tmcp/session-manager-postgres\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i @tmcp/session-manager-postgres\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add @tmcp/session-manager-postgres\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add @tmcp/session-manager-postgres\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else if session_manager === \"Cloudflare KV/Durable Objects\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add @tmcp/session-manager-durable-objects\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i @tmcp/session-manager-durable-objects\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add @tmcp/session-manager-durable-objects\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add @tmcp/session-manager-durable-objects\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{/if}</p>\n<p>{/snippet}</p>\n\n<p>And use it in your transport.</p>\n<card href=\"/docs/session-managers/overview\" title=\"Learn how to use the session managers\" icon=\"{ArrowRight}\" horizontal=\"\">\nYou can learn more about how to use a session manager in the section dedicated to it.\n</card>\n</packagemanagers></packagemanagers></packagemanagers></packagemanagers></packagemanagers></packagemanagers></packagemanagers></packagemanagers></packagemanagers></packagemanagers></packagemanagers></packagemanagers></packagemanagers></steps>",
    "raw": "<script>\n\timport { Steps, Step, Callout, Card } from \"@svecodocs/kit\";\n\timport PackageManagers from \"$lib/components/package-managers.svelte\";\n\timport Select from \"$lib/components/select.svelte\";\n\timport ArrowRight from \"phosphor-svelte/lib/ArrowRight\";\n</script>\n\nYou have two ways to setup your project with `tmcp` to start building your MCP server:\n\n## Using the cli\n\n<Steps>\n<Step>Run the CLI</Step>\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm create tmcp\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm init tmcp\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn create tmcp\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun create tmcp\n```\n\n{/snippet}\n</PackageManagers>\n<Step>Follow the wizard üßôüèª</Step>\n\nThe wizard will guide you towards the creation of a `tmcp` project. It will ask you for where do you want to create your project, which JSON schema adapter you want to use, which transport you want to use and if you want to include helpers to authenticate your MCP servers.\n\nIt will also ask you if you want to have an example MCP server that will create a file with the minimal boilerplate (using `srvx` in case you are building an HTTP server).\n\n```bash\n‚îå  üöÄ Welcome to create-tmcp!\n‚îÇ\n‚óá  Where should we create your TMCP project?\n‚îÇ  my-awesome-mcp\n‚îÇ\n‚óá  Which schema adapter would you like to use?\n‚îÇ  Valibot (Recommended)\n‚îÇ\n‚óá  Which transports would you like to include?\n‚îÇ  STDIO, HTTP\n‚îÇ\n‚óá  Would you like to include OAuth 2.1 authentication?\n‚îÇ  Yes\n‚îÇ\n‚óá  Would you like to include an example MCP server?\n‚îÇ  Yes\n‚îÇ\n‚óá  Where should we place the example server?\n‚îÇ  src/index.js\n‚îÇ\n‚óá  Would you like to automatically install dependencies?\n‚îÇ  Yes\n‚îÇ\n‚óá  Which package manager would you like to use?\n‚îÇ  pnpm (Recommended)\n‚îÇ\n‚óá  Project created successfully!\n‚îÇ\n‚óá  Next steps: ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ                     ‚îÇ\n‚îÇ  cd my-awesome-mcp  ‚îÇ\n‚îÇ  pnpm run dev       ‚îÇ\n‚îÇ                     ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n‚îÇ\n‚îî  Happy coding! üéâ\n```\n\n<Step>That's it</Step>\n\nThat's it, `cd` into your folder and start building your awesome mcp server!\n\n</Steps>\n\n<Callout type=\"tip\" title=\"Info\">\n\nThe installer will create a `package.json` with the latest version of the required dependencies. If you want you can also run the boilerplate CLI in an existing project and it merge with your existing `package.json`.\n\n</Callout>\n\n## Manual installation\n\n`tmcp` is very composable: what this means is that each functionality it's separated in it's own package so you only get the bare minimum dependencies depending on what you are building.\n\nSo to setup a project manually you need to follow some steps:\n\n<Steps>\n<Step>Install `tmcp`</Step>\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add tmcp\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i tmcp\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add tmcp\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add tmcp\n```\n\n{/snippet}\n</PackageManagers>\n\n<Step>Choose a validation library</Step>\n\nThere are several adapters to convert from your validation library to JSON schema (the required format for the MCP protocol):\n\n- Valibot\n- Zod (v3 and v4)\n- Arktype\n- Effect\n\nonce you have picked your dependency install the validation library AND the relative `tmcp` adapter\n\n<Select options={[\"valibot\", \"zod\", \"zod (v3)\", \"arktype\", \"effect\"]} title=\"Adapter\">\n{#snippet children(adapter)}\n\n{#if adapter === \"valibot\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add valibot @tmcp/adapter-valibot\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i valibot @tmcp/adapter-valibot\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add valibot @tmcp/adapter-valibot\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add valibot @tmcp/adapter-valibot\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else if adapter === \"zod\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add zod @tmcp/adapter-zod\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i zod @tmcp/adapter-zod\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add zod @tmcp/adapter-zod\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add zod @tmcp/adapter-zod\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else if adapter === \"zod (v3)\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add zod @tmcp/adapter-zod-v3\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i zod @tmcp/adapter-zod-v3\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add zod @tmcp/adapter-zod-v3\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add zod @tmcp/adapter-zod-v3\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else if adapter === \"arktype\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add arktype @tmcp/adapter-arktype\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i arktype @tmcp/adapter-arktype\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add arktype @tmcp/adapter-arktype\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add arktype @tmcp/adapter-arktype\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add effect-ts @tmcp/adapter-effect\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i effect-ts @tmcp/adapter-effect\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add effect-ts @tmcp/adapter-effect\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add effect-ts @tmcp/adapter-effect\n```\n\n{/snippet}\n</PackageManagers>\n\n{/if}\n\n{/snippet}\n\n</Select>\n\n<Step>Pick your transport</Step>\n\nThe core `tmcp` library is just a JSON-rpc server...to communicate you need to install an adapter. You can pick between three different adapters\n\n- **STDIO**: used to build local servers that can be published on `npm` and communicate over `stdin` and `stdout`\n- **HTTP**: used to build remote servers. You can deploy them anywhere node/bun/deno run and use Streamable HTTP to communicate with your MCP client.\n- **SSE**: also used to build remote servers. This transport is officially deprecated in the MCP spec so you should default to HTTP if possible.\n\n<Select options={[\"STDIO\", \"HTTP\", \"SSE\"]} title=\"Transport\">\n\n{#snippet children(transport)}\n\n{#if transport === \"STDIO\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add @tmcp/transport-stdio\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i @tmcp/transport-stdio\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add @tmcp/transport-stdio\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add @tmcp/transport-stdio\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else if transport === \"HTTP\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add @tmcp/transport-http\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i @tmcp/transport-http\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add @tmcp/transport-http\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add @tmcp/transport-http\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else if transport === \"SSE\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add @tmcp/transport-sse\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i @tmcp/transport-sse\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add @tmcp/transport-sse\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add @tmcp/transport-sse\n```\n\n{/snippet}\n</PackageManagers>\n\n{/if}\n\n{/snippet}\n\n</Select>\n\n<Step>(Optional) Install the Auth helper</Step>\n\nIf you plan to use authentication for your MCP server `tmcp` you will need to act as an _Authorization server_. This can be challenging and that's why `tmcp`¬†ships with a package dedicated to authentication. You can install it like this\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add @tmcp/auth\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i @tmcp/auth\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add @tmcp/auth\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add @tmcp/auth\n```\n\n{/snippet}\n</PackageManagers>\n\nAnd use it in your transport.\n\n<Card href=\"/docs/auth/oauth\" title=\"Learn how to use the authentication helpers\" icon={ArrowRight} horizontal>\nYou can learn more about how to use the authentication helpers in the section dedicated to it.\n</Card>\n\n<Step>(Optional) Install the Session manager helper</Step>\n\nBuilding a remote MCP server at scale means either serverless or a distributed environment and that doesn't go well with the in-memory default behaviour of MCP servers. To ease that experience `tmcp`¬†provides a session manager abstraction that solves two problems:\n\n1. when sending back notifications from the server (or if you are using the SSE transport) the handle of the SSE stream could be in a different server than the one receiving the POST request that triggers it\n2. all the information about the current MCP client (like client capabilities, client info, resources subscriptions) are stored in a different server than the one receiving the current POST request.\n\nA session manager exports two classes that uses an external system (redis, postgres, cloudflare durable objects) to store this information and as a pub/sub dispatcher. Pick your player, install it like this:\n\n<Select options={[\"Redis\", \"Postgres\", \"Cloudflare KV/Durable Objects\"]} title=\"Session Manager\">\n\n{#snippet children(session_manager)}\n\n{#if session_manager === \"Redis\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add @tmcp/session-manager-redis\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i @tmcp/session-manager-redis\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add @tmcp/session-manager-redis\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add @tmcp/session-manager-redis\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else if session_manager === \"Postgres\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add @tmcp/session-manager-postgres\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i @tmcp/session-manager-postgres\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add @tmcp/session-manager-postgres\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add @tmcp/session-manager-postgres\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else if session_manager === \"Cloudflare KV/Durable Objects\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add @tmcp/session-manager-durable-objects\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i @tmcp/session-manager-durable-objects\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add @tmcp/session-manager-durable-objects\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add @tmcp/session-manager-durable-objects\n```\n\n{/snippet}\n</PackageManagers>\n\n{/if}\n\n{/snippet}\n\n</Select>\n\nAnd use it in your transport.\n\n<Card href=\"/docs/session-managers/overview\" title=\"Learn how to use the session managers\" icon={ArrowRight} horizontal>\nYou can learn more about how to use a session manager in the section dedicated to it.\n</Card>\n\n</Steps>",
    "toc": [
      {
        "title": "Using the cli",
        "url": "#using-the-cli",
        "items": []
      },
      {
        "title": "Manual installation",
        "url": "#manual-installation",
        "items": []
      }
    ],
    "section": "Overview",
    "slug": "000-getting-started",
    "slugFull": "/000-getting-started"
  },
  {
    "title": "Introduction",
    "description": "What and why is tmcp a thing?",
    "path": "000-index",
    "content": "<p>If you are ever come close to the world of Agentic AI I'm sure you've come across a certain acronym: MCP.</p>\n<h2>MCP: Model Context Protocol</h2>\n<p>As the name suggest Model Context Protocol is...well...a Protocol. Just like HTTP allow browsers (HTTP client) to communicate back and forth with our servers (HTTP server), MCP allows MCP clients to communicate back and forth with MCP servers. To do what? To allow LLMs (the Model in the acronym) to get additional Context (the Context in the acronym) and act on behalf of the user!</p>\n<p>The MCP is a way to standardize the communication method between those clients (<code>claude-code</code>, <code>codex</code>, <code>copilot</code> etc) and the servers (what you are probably here to build).</p>\n<p>The initiative was launched by Anthropic and quickly gained popularity and now has thousands of users.</p>\n<p>If you are interested <a href=\"https://modelcontextprotocol.io/docs/getting-started/intro\">you can read more here</a> but you are here to learn about <code>tmcp</code> so...</p>\n<h2><code>tmcp</code> a modern way to build MCP servers</h2>\n<p>Most modern platform nowadays standardized on the <code>fetch</code> API to handle their requests/responses. SvelteKit, Next.js, SolidStart, Bun, Cloudflare Workers, Deno, they all handle HTTP calls in the same way: you expose a function that receives a <code>Request</code> instance and return a <code>Response</code> instance from it.</p>\n<p>Simple, performant, modern.</p>\n<p>There's also a lot of validation libraries out there: <a href=\"https://valibot.dev\">Valibot</a>, <a href=\"https://arktype.io\">Arktype</a>, <a href=\"https://effect.website\">Effect</a> each with it's own strength and as a library author you don't have to pick your favorite: you can use <a href=\"https://github.com/standard-schema/standard-schema\">Standard Schema</a> to allow your users to pick their favorite!</p>\n<p>This and much more were the reasons that moved us to build <code>tmcp</code>: a simple, composable, modern and flexible SDK to build your MCP server where YOU get to pick your deployment target, you validation library and your preferred transport without all the rest coming as a baggage!</p>\n<p>But enough blabblering...you want to see the code!</p>",
    "raw": "If you are ever come close to the world of Agentic AI I'm sure you've come across a certain acronym: MCP.\n\n## MCP: Model Context Protocol\n\nAs the name suggest Model Context Protocol is...well...a Protocol. Just like HTTP allow browsers (HTTP client) to communicate back and forth with our servers (HTTP server), MCP allows MCP clients to communicate back and forth with MCP servers. To do what? To allow LLMs (the Model in the acronym) to get additional Context (the Context in the acronym) and act on behalf of the user!\n\nThe MCP is a way to standardize the communication method between those clients (`claude-code`, `codex`, `copilot` etc) and the servers (what you are probably here to build).\n\nThe initiative was launched by Anthropic and quickly gained popularity and now has thousands of users.\n\nIf you are interested [you can read more here](https://modelcontextprotocol.io/docs/getting-started/intro) but you are here to learn about `tmcp` so...\n\n## `tmcp` a modern way to build MCP servers\n\nMost modern platform nowadays standardized on the `fetch` API to handle their requests/responses. SvelteKit, Next.js, SolidStart, Bun, Cloudflare Workers, Deno, they all handle HTTP calls in the same way: you expose a function that receives a `Request` instance and return a `Response` instance from it.\n\nSimple, performant, modern.\n\nThere's also a lot of validation libraries out there: [Valibot](https://valibot.dev), [Arktype](https://arktype.io), [Effect](https://effect.website) each with it's own strength and as a library author you don't have to pick your favorite: you can use [Standard Schema](https://github.com/standard-schema/standard-schema) to allow your users to pick their favorite!\n\nThis and much more were the reasons that moved us to build `tmcp`: a simple, composable, modern and flexible SDK to build your MCP server where YOU get to pick your deployment target, you validation library and your preferred transport without all the rest coming as a baggage!\n\nBut enough blabblering...you want to see the code!",
    "toc": [
      {
        "title": "MCP: Model Context Protocol",
        "url": "#mcp-model-context-protocol",
        "items": []
      },
      {
        "title": "tmcp a modern way to build MCP servers",
        "url": "#tmcp-a-modern-way-to-build-mcp-servers",
        "items": []
      }
    ],
    "section": "Overview",
    "slug": "000-index",
    "slugFull": "/000-index"
  },
  {
    "title": "OAuth",
    "description": "Learn how to setup OAuth for your MCP server using the OAuth helper from `@tmcp/auth`",
    "path": "auth/100-oauth",
    "content": "<p>Puppa</p>",
    "raw": "Puppa",
    "toc": [],
    "section": "Auth",
    "slug": "auth/100-oauth",
    "slugFull": "/auth/100-oauth"
  },
  {
    "title": "SimpleProvider",
    "description": "Learn how to setup OAuth for your MCP server using the SimpleProvider helper from `@tmcp/auth`",
    "path": "auth/200-simple-provider",
    "content": "<p>Puppa</p>",
    "raw": "Puppa",
    "toc": [],
    "section": "Auth",
    "slug": "auth/200-simple-provider",
    "slugFull": "/auth/200-simple-provider"
  },
  {
    "title": "McpServer",
    "description": "The main McpServer class",
    "path": "core/100-mcp-server",
    "content": "<script>\n\timport { Callout, Card } from \"@svecodocs/kit\";\n\timport PackageManagers from \"$lib/components/package-managers.svelte\";\n\timport Select from \"$lib/components/select.svelte\";\n</script>\n<p>This is the instance that controls the logic behind your MCP server. You will use this instance to register your tool/resource/prompts, to send notifications, to read the context etc.</p>\n<p>At his heart this class is basically a JSON-rpc server and you can use the method <a href=\"/docs/core/receive\">receive</a> to handle JSON-rpc payloads.</p>\n<h2>Initialization</h2>\n<p><code>McpServer</code> is a class that you can instantiate with the information of your server (mainly name and version) and your capabilities:</p>\n<pre><code class=\"language-ts\">const server = new McpServer(\n\t{\n\t\tname: 'a-super-basic-server',\n\t\tversion: '1.0.0',\n\t},\n\t{\n\t\tadapter: undefined,\n\t\tcapabilities: {},\n\t},\n);\n</code></pre>\n<p>this will give you a very basic server that can only respond to <code>ping</code> requests and <code>initialize</code> requests. You can enhance your capabilities by specifying them in the <code>capabilities</code> object:</p>\n<pre><code class=\"language-ts\">const server = new McpServer(\n\t{\n\t\tname: 'my-awesome-server',\n\t\tversion: '1.0.0',\n\t},\n\t{\n\t\tadapter: undefined,\n\t\tcapabilities: {\n\t\t\ttools: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tresources: {\n\t\t\t\tsubscribe: true,\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tprompts: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tlogging: {},\n\t\t\tcompletions: {},\n\t\t},\n\t},\n);\n</code></pre>\n<callout type=\"warning\">\nIf you don't include a capability registering a tool/resource/prompt will not automatically include that capability and the server will not respond to that method invocation.\n</callout>\n<p>You might notice something unusual in both of this code snippets: we are explicitly setting the <code>adapter</code> to <code>undefined</code>. The adapter is required to receive any kind of input or to send elicitation requests so, unless you are planning only to add tools that don't receive any input you should actually specify an adapter. As a nicety and for quick prototyping you can omit the adapter but you will get errors as soon as you try to define a schema for a tool so that's why you need to specifically pass <code>undefined</code>.</p>\n<p>But we are not prototyping here so...</p>\n<h2>Specifying an adapter</h2>\n<p>The official MCP spec requires the server to send back the information about the input of a tool/prompt (or the requested schema of an elicitation request) in JSON-schema. While very powerful JSON-schema is also very verbose and very often developers already have a validation library installed in their project.</p>\n<p>Thanks to <a href=\"https://github.com/standard-schema/standard-schema\">standard schema</a> you can use every library that supports standard schema with <code>tmcp</code>. However we still need a way to convert from your validation library of choice to JSON-schema and that could be as simple as doing <code>schema.toJSONSchema()</code> in zod version 4 or as complex as finding and installing a separate library to do it for you (like zod v3 or valibot).</p>\n<p>Introducing, adapters.</p>\n<p>We did most of the work for you for the most common validation libraries:</p>\n<ul>\n<li>Valibot</li>\n<li>Zod V3</li>\n<li>Zod V4</li>\n<li>Arktype</li>\n<li>Effect</li>\n</ul>\n<p>so if you are using one of these libraries you are golden: just run</p>\n<p>&#x3C;Select options={[\"valibot\", \"zod\", \"zod (v3)\", \"arktype\", \"effect\"]} title=\"Adapter\">\n{#snippet children(adapter)}</p>\n<p>{#if adapter === \"valibot\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add valibot @tmcp/adapter-valibot\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i valibot @tmcp/adapter-valibot\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add valibot @tmcp/adapter-valibot\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add valibot @tmcp/adapter-valibot\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else if adapter === \"zod\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add zod @tmcp/adapter-zod\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i zod @tmcp/adapter-zod\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add zod @tmcp/adapter-zod\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add zod @tmcp/adapter-zod\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else if adapter === \"zod (v3)\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add zod @tmcp/adapter-zod-v3\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i zod @tmcp/adapter-zod-v3\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add zod @tmcp/adapter-zod-v3\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add zod @tmcp/adapter-zod-v3\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else if adapter === \"arktype\"}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add arktype @tmcp/adapter-arktype\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i arktype @tmcp/adapter-arktype\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add arktype @tmcp/adapter-arktype\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add arktype @tmcp/adapter-arktype\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{:else}</p>\n<packagemanagers>\n{#snippet pnpm()}\n<pre><code class=\"language-bash\">pnpm add effect-ts @tmcp/adapter-effect\n</code></pre>\n<p>{/snippet}\n{#snippet npm()}</p>\n<pre><code class=\"language-bash\">npm i effect-ts @tmcp/adapter-effect\n</code></pre>\n<p>{/snippet}\n{#snippet yarn()}</p>\n<pre><code class=\"language-bash\">yarn add effect-ts @tmcp/adapter-effect\n</code></pre>\n<p>{/snippet}</p>\n<p>{#snippet bun()}</p>\n<pre><code class=\"language-bash\">bun add effect-ts @tmcp/adapter-effect\n</code></pre>\n<p>{/snippet}\n</p>\n<p>{/if}</p>\n<p>{/snippet}</p>\n\n<p>once you do that you'll find a named export with a descriptive name that you can instantiate and pass as adapter to your McpServer class.</p>\n<pre><code class=\"language-ts\">import { ValibotJsonSchemaAdapter } from '@tmcp/adapter-valibot';\n\nconst server = new McpServer(\n\t{\n\t\tname: 'a-super-basic-server',\n\t\tversion: '1.0.0',\n\t},\n\t{\n\t\tadapter: new ValibotJsonSchemaAdapter(),\n\t\tcapabilities: {},\n\t},\n);\n</code></pre>\n<p>Then you will be able to pass <code>valibot</code> schemas to your tools/prompts/elicitations.</p>\n<details class=\"mt-4\">\n\t<summary class=\"text-xl\">What if my standard schema library is not one of those?</summary>\n<p>Don't worry!</p>\n<p>Writing your own adapter is very simple (given that your library supports converting into JSON-schema...if that's not the case I have bad news üòÖ).</p>\n<p><code>tmcp</code> also¬†exports a class named <code>JsonSchemaAdapter</code>, all you have to do is create a class extends that class and override the <code>toJsonSchema</code> method</p>\n<pre><code class=\"language-ts\">import { JsonSchemaAdapter } from 'tmcp/adapter';\n// every validation library exports their base type\n// which needs to be a StandardSchema compatible type\nimport type { BaseSchemaType } from 'your-validation-library';\n\nclass MyCustomJsonSchemaAdapter extends JsonSchemaAdapter&#x3C;BaseSchemaType> {\n\tasync toJsonSchema(schema: BaseSchemaType) {\n\t\t// find a way to convert to json schema\n\t\treturn schema.toJsonSchema();\n\t}\n}\n</code></pre>\n<p>That's it! Now you can use your library with <code>tmcp</code>...and if you feel it you can also <a href=\"https://github.com/paoloricciuti/tmcp/pulls\">open a PR</a> to <code>tmcp</code> to make this an officially supported library!</p>\n</details>\n<h2>Server instructions</h2>\n<p>An optional property of the configuration object is <code>instructions</code>...you can fill this to instruct the LLM on how and when to use your server</p>\n<pre><code class=\"language-ts\" metastring=\"{22-23}\">const server = new McpServer(\n\t{\n\t\tname: 'my-awesome-server',\n\t\tversion: '1.0.0',\n\t},\n\t{\n\t\tadapter: undefined,\n\t\tcapabilities: {\n\t\t\ttools: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tresources: {\n\t\t\t\tsubscribe: true,\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tprompts: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tlogging: {},\n\t\t\tcompletions: {},\n\t\t},\n\t\tinstructions:\n\t\t\t'You can use the server to do the most awesome thing in the world',\n\t},\n);\n</code></pre>\n<h2>Pagination options</h2>\n<p>The MCP spec allows servers to paginate the results of list calls so that if you have a lot of tools/resources/prompts you can send them in batches instead of returning a single list that could overflow the tokens limits of some agent. <code>tmcp</code> handle all of this for you automatically, you just need to specify the page size:</p>\n<pre><code class=\"language-ts\" metastring=\"{22-32}\">const server = new McpServer(\n\t{\n\t\tname: 'my-awesome-server',\n\t\tversion: '1.0.0',\n\t},\n\t{\n\t\tadapter: undefined,\n\t\tcapabilities: {\n\t\t\ttools: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tresources: {\n\t\t\t\tsubscribe: true,\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tprompts: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tlogging: {},\n\t\t\tcompletions: {},\n\t\t},\n\t\tpagination: {\n\t\t\tprompts: {\n\t\t\t\tsize: 15,\n\t\t\t},\n\t\t\ttools: {\n\t\t\t\tsize: 15,\n\t\t\t},\n\t\t\tresources: {\n\t\t\t\tsize: 15,\n\t\t\t},\n\t\t},\n\t},\n);\n</code></pre>\n<h2>Context</h2>\n<p>We are gonna explore how context work <a href=\"/docs/core/ctx\">in it's own section</a> but is worth mentioning here that after you create you <code>McpServer</code> instance you have a <code>withContext</code> utility that allows you to specify the type for the custom context you expect. This type flows through the transports and in the <code>server.ctx</code> getter so you can actually get intellisense about the context you defined. To specify a type you can do:</p>\n<pre><code class=\"language-ts\">const server = new McpServer({...}).withContext&#x3C;{ db: Db }>();\n</code></pre></packagemanagers></packagemanagers></packagemanagers></packagemanagers></packagemanagers>",
    "raw": "<script>\n\timport { Callout, Card } from \"@svecodocs/kit\";\n\timport PackageManagers from \"$lib/components/package-managers.svelte\";\n\timport Select from \"$lib/components/select.svelte\";\n</script>\n\nThis is the instance that controls the logic behind your MCP server. You will use this instance to register your tool/resource/prompts, to send notifications, to read the context etc.\n\nAt his heart this class is basically a JSON-rpc server and you can use the method [receive](/docs/core/receive) to handle JSON-rpc payloads.\n\n## Initialization\n\n`McpServer` is a class that you can instantiate with the information of your server (mainly name and version) and your capabilities:\n\n```ts\nconst server = new McpServer(\n\t{\n\t\tname: 'a-super-basic-server',\n\t\tversion: '1.0.0',\n\t},\n\t{\n\t\tadapter: undefined,\n\t\tcapabilities: {},\n\t},\n);\n```\n\nthis will give you a very basic server that can only respond to `ping` requests and `initialize` requests. You can enhance your capabilities by specifying them in the `capabilities` object:\n\n```ts\nconst server = new McpServer(\n\t{\n\t\tname: 'my-awesome-server',\n\t\tversion: '1.0.0',\n\t},\n\t{\n\t\tadapter: undefined,\n\t\tcapabilities: {\n\t\t\ttools: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tresources: {\n\t\t\t\tsubscribe: true,\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tprompts: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tlogging: {},\n\t\t\tcompletions: {},\n\t\t},\n\t},\n);\n```\n\n<Callout type=\"warning\">\nIf you don't include a capability registering a tool/resource/prompt will not automatically include that capability and the server will not respond to that method invocation.\n</Callout>\n\nYou might notice something unusual in both of this code snippets: we are explicitly setting the `adapter` to `undefined`. The adapter is required to receive any kind of input or to send elicitation requests so, unless you are planning only to add tools that don't receive any input you should actually specify an adapter. As a nicety and for quick prototyping you can omit the adapter but you will get errors as soon as you try to define a schema for a tool so that's why you need to specifically pass `undefined`.\n\nBut we are not prototyping here so...\n\n## Specifying an adapter\n\nThe official MCP spec requires the server to send back the information about the input of a tool/prompt (or the requested schema of an elicitation request) in JSON-schema. While very powerful JSON-schema is also very verbose and very often developers already have a validation library installed in their project.\n\nThanks to [standard schema](https://github.com/standard-schema/standard-schema) you can use every library that supports standard schema with `tmcp`. However we still need a way to convert from your validation library of choice to JSON-schema and that could be as simple as doing `schema.toJSONSchema()` in zod version 4 or as complex as finding and installing a separate library to do it for you (like zod v3 or valibot).\n\nIntroducing, adapters.\n\nWe did most of the work for you for the most common validation libraries:\n\n- Valibot\n- Zod V3\n- Zod V4\n- Arktype\n- Effect\n\nso if you are using one of these libraries you are golden: just run\n\n<Select options={[\"valibot\", \"zod\", \"zod (v3)\", \"arktype\", \"effect\"]} title=\"Adapter\">\n{#snippet children(adapter)}\n\n{#if adapter === \"valibot\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add valibot @tmcp/adapter-valibot\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i valibot @tmcp/adapter-valibot\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add valibot @tmcp/adapter-valibot\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add valibot @tmcp/adapter-valibot\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else if adapter === \"zod\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add zod @tmcp/adapter-zod\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i zod @tmcp/adapter-zod\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add zod @tmcp/adapter-zod\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add zod @tmcp/adapter-zod\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else if adapter === \"zod (v3)\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add zod @tmcp/adapter-zod-v3\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i zod @tmcp/adapter-zod-v3\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add zod @tmcp/adapter-zod-v3\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add zod @tmcp/adapter-zod-v3\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else if adapter === \"arktype\"}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add arktype @tmcp/adapter-arktype\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i arktype @tmcp/adapter-arktype\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add arktype @tmcp/adapter-arktype\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add arktype @tmcp/adapter-arktype\n```\n\n{/snippet}\n</PackageManagers>\n\n{:else}\n\n<PackageManagers>\n{#snippet pnpm()}\n\n```bash\npnpm add effect-ts @tmcp/adapter-effect\n```\n\n{/snippet}\n{#snippet npm()}\n\n```bash\nnpm i effect-ts @tmcp/adapter-effect\n```\n\n{/snippet}\n{#snippet yarn()}\n\n```bash\nyarn add effect-ts @tmcp/adapter-effect\n```\n\n{/snippet}\n\n{#snippet bun()}\n\n```bash\nbun add effect-ts @tmcp/adapter-effect\n```\n\n{/snippet}\n</PackageManagers>\n\n{/if}\n\n{/snippet}\n\n</Select>\n\nonce you do that you'll find a named export with a descriptive name that you can instantiate and pass as adapter to your McpServer class.\n\n```ts\nimport { ValibotJsonSchemaAdapter } from '@tmcp/adapter-valibot';\n\nconst server = new McpServer(\n\t{\n\t\tname: 'a-super-basic-server',\n\t\tversion: '1.0.0',\n\t},\n\t{\n\t\tadapter: new ValibotJsonSchemaAdapter(),\n\t\tcapabilities: {},\n\t},\n);\n```\n\nThen you will be able to pass `valibot` schemas to your tools/prompts/elicitations.\n\n<details class=\"mt-4\">\n\t<summary class=\"text-xl\">What if my standard schema library is not one of those?</summary>\n\nDon't worry!\n\nWriting your own adapter is very simple (given that your library supports converting into JSON-schema...if that's not the case I have bad news üòÖ).\n\n`tmcp` also¬†exports a class named `JsonSchemaAdapter`, all you have to do is create a class extends that class and override the `toJsonSchema` method\n\n```ts\nimport { JsonSchemaAdapter } from 'tmcp/adapter';\n// every validation library exports their base type\n// which needs to be a StandardSchema compatible type\nimport type { BaseSchemaType } from 'your-validation-library';\n\nclass MyCustomJsonSchemaAdapter extends JsonSchemaAdapter<BaseSchemaType> {\n\tasync toJsonSchema(schema: BaseSchemaType) {\n\t\t// find a way to convert to json schema\n\t\treturn schema.toJsonSchema();\n\t}\n}\n```\n\nThat's it! Now you can use your library with `tmcp`...and if you feel it you can also [open a PR](https://github.com/paoloricciuti/tmcp/pulls) to `tmcp` to make this an officially supported library!\n\n</details>\n\n## Server instructions\n\nAn optional property of the configuration object is `instructions`...you can fill this to instruct the LLM on how and when to use your server\n\n```ts {22-23}\nconst server = new McpServer(\n\t{\n\t\tname: 'my-awesome-server',\n\t\tversion: '1.0.0',\n\t},\n\t{\n\t\tadapter: undefined,\n\t\tcapabilities: {\n\t\t\ttools: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tresources: {\n\t\t\t\tsubscribe: true,\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tprompts: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tlogging: {},\n\t\t\tcompletions: {},\n\t\t},\n\t\tinstructions:\n\t\t\t'You can use the server to do the most awesome thing in the world',\n\t},\n);\n```\n\n## Pagination options\n\nThe MCP spec allows servers to paginate the results of list calls so that if you have a lot of tools/resources/prompts you can send them in batches instead of returning a single list that could overflow the tokens limits of some agent. `tmcp` handle all of this for you automatically, you just need to specify the page size:\n\n```ts {22-32}\nconst server = new McpServer(\n\t{\n\t\tname: 'my-awesome-server',\n\t\tversion: '1.0.0',\n\t},\n\t{\n\t\tadapter: undefined,\n\t\tcapabilities: {\n\t\t\ttools: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tresources: {\n\t\t\t\tsubscribe: true,\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tprompts: {\n\t\t\t\tlistChanged: true,\n\t\t\t},\n\t\t\tlogging: {},\n\t\t\tcompletions: {},\n\t\t},\n\t\tpagination: {\n\t\t\tprompts: {\n\t\t\t\tsize: 15,\n\t\t\t},\n\t\t\ttools: {\n\t\t\t\tsize: 15,\n\t\t\t},\n\t\t\tresources: {\n\t\t\t\tsize: 15,\n\t\t\t},\n\t\t},\n\t},\n);\n```\n\n## Context\n\nWe are gonna explore how context work [in it's own section](/docs/core/ctx) but is worth mentioning here that after you create you `McpServer` instance you have a `withContext` utility that allows you to specify the type for the custom context you expect. This type flows through the transports and in the `server.ctx` getter so you can actually get intellisense about the context you defined. To specify a type you can do:\n\n```ts\nconst server = new McpServer({...}).withContext<{ db: Db }>();\n```",
    "toc": [
      {
        "title": "Initialization",
        "url": "#initialization",
        "items": []
      },
      {
        "title": "Specifying an adapter",
        "url": "#specifying-an-adapter",
        "items": []
      },
      {
        "title": "Server instructions",
        "url": "#server-instructions",
        "items": []
      },
      {
        "title": "Pagination options",
        "url": "#pagination-options",
        "items": []
      },
      {
        "title": "Context",
        "url": "#context",
        "items": []
      }
    ],
    "section": "Core",
    "slug": "core/100-mcp-server",
    "slugFull": "/core/100-mcp-server"
  },
  {
    "title": "refreshRoots",
    "description": "Learn how to refresh the list of allowed workspace folders from the client",
    "path": "core/1000-refreshRoots",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Core",
    "slug": "core/1000-refreshRoots",
    "slugFull": "/core/1000-refreshRoots"
  },
  {
    "title": "log",
    "description": "Learn how to refresh the list of allowed workspace folders from the client",
    "path": "core/1100-log",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Core",
    "slug": "core/1100-log",
    "slugFull": "/core/1100-log"
  },
  {
    "title": "progress",
    "description": "Learn how to refresh the list of allowed workspace folders from the client",
    "path": "core/1200-progress",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Core",
    "slug": "core/1200-progress",
    "slugFull": "/core/1200-progress"
  },
  {
    "title": "changed",
    "description": "Learn how to refresh the list of allowed workspace folders from the client",
    "path": "core/1300-changed",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Core",
    "slug": "core/1300-changed",
    "slugFull": "/core/1300-changed"
  },
  {
    "title": "receive",
    "description": "The main entrypoint to your MCP server",
    "path": "core/1400-receive",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Core",
    "slug": "core/1400-receive",
    "slugFull": "/core/1400-receive"
  },
  {
    "title": "request",
    "description": "The main entrypoint to your MCP server",
    "path": "core/1500-request",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Core",
    "slug": "core/1500-request",
    "slugFull": "/core/1500-request"
  },
  {
    "title": "tool",
    "description": "The start of the MCP protocol...learn how to register a tool that can be called by your Agent.",
    "path": "core/200-tool",
    "content": "<p>tool</p>",
    "raw": "tool",
    "toc": [],
    "section": "Core",
    "slug": "core/200-tool",
    "slugFull": "/core/200-tool"
  },
  {
    "title": "resource",
    "description": "Learn how to register a new resource for your MCP server.",
    "path": "core/300-resource",
    "content": "<p>resource</p>",
    "raw": "resource",
    "toc": [],
    "section": "Core",
    "slug": "core/300-resource",
    "slugFull": "/core/300-resource"
  },
  {
    "title": "template",
    "description": "Learn how to register a new dynamic resource for your MCP server.",
    "path": "core/400-template",
    "content": "<p>template</p>",
    "raw": "template",
    "toc": [],
    "section": "Core",
    "slug": "core/400-template",
    "slugFull": "/core/400-template"
  },
  {
    "title": "prompt",
    "description": "Learn how to register a new prompt for your MCP server.",
    "path": "core/500-prompt",
    "content": "<p>prompt</p>",
    "raw": "prompt",
    "toc": [],
    "section": "Core",
    "slug": "core/500-prompt",
    "slugFull": "/core/500-prompt"
  },
  {
    "title": "on",
    "description": "Learn how to register event listeners on the MCP server and which events are available.",
    "path": "core/600-on",
    "content": "<p>on</p>",
    "raw": "on",
    "toc": [],
    "section": "Core",
    "slug": "core/600-on",
    "slugFull": "/core/600-on"
  },
  {
    "title": "ctx",
    "description": "Learn everything about the context available on the server.",
    "path": "core/700-ctx",
    "content": "<p>ctx</p>",
    "raw": "ctx",
    "toc": [],
    "section": "Core",
    "slug": "core/700-ctx",
    "slugFull": "/core/700-ctx"
  },
  {
    "title": "elicitation",
    "description": "Learn how to ask for more information from the MCP client",
    "path": "core/800-elicitation",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Core",
    "slug": "core/800-elicitation",
    "slugFull": "/core/800-elicitation"
  },
  {
    "title": "message",
    "description": "Learn how to request the user to use the LLM to do inference work",
    "path": "core/900-message",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Core",
    "slug": "core/900-message",
    "slugFull": "/core/900-message"
  },
  {
    "title": "HTTP",
    "description": "Learn how to run and deploy your server remotely everywhere JS runs.",
    "path": "transports/100-http",
    "content": "<p>HTTP</p>",
    "raw": "HTTP",
    "toc": [],
    "section": "Transports",
    "slug": "transports/100-http",
    "slugFull": "/transports/100-http"
  },
  {
    "title": "STDIO",
    "description": "Learn how to build an MCP server that runs locally.",
    "path": "transports/200-stdio",
    "content": "<p>stdio</p>",
    "raw": "stdio",
    "toc": [],
    "section": "Transports",
    "slug": "transports/200-stdio",
    "slugFull": "/transports/200-stdio"
  },
  {
    "title": "SSE",
    "description": "Learn how to run and deploy your server remotely everywhere JS runs using the deprecated SSE transport.",
    "path": "transports/300-sse",
    "content": "<p>SSE</p>",
    "raw": "SSE",
    "toc": [],
    "section": "Transports",
    "slug": "transports/300-sse",
    "slugFull": "/transports/300-sse"
  },
  {
    "title": "Redis",
    "description": "Learn how to run and deploy your server remotely everywhere JS runs.",
    "path": "session-managers/100-redis",
    "content": "<p>HTTP</p>",
    "raw": "HTTP",
    "toc": [],
    "section": "Session Managers",
    "slug": "session-managers/100-redis",
    "slugFull": "/session-managers/100-redis"
  },
  {
    "title": "Postgres",
    "description": "Learn how to run and deploy your server remotely everywhere JS runs.",
    "path": "session-managers/200-stdio",
    "content": "<p>HTTP</p>",
    "raw": "HTTP",
    "toc": [],
    "section": "Session Managers",
    "slug": "session-managers/200-stdio",
    "slugFull": "/session-managers/200-stdio"
  },
  {
    "title": "Durable Objects",
    "description": "Learn how to run and deploy your server remotely everywhere JS runs.",
    "path": "session-managers/300-sse",
    "content": "<p>HTTP</p>",
    "raw": "HTTP",
    "toc": [],
    "section": "Session Managers",
    "slug": "session-managers/300-sse",
    "slugFull": "/session-managers/300-sse"
  },
  {
    "title": "Overview",
    "description": "Learn how to run and deploy your server remotely everywhere JS runs.",
    "path": "session-managers/50-overview",
    "content": "",
    "raw": "",
    "toc": [],
    "section": "Session Managers",
    "slug": "session-managers/50-overview",
    "slugFull": "/session-managers/50-overview"
  },
  {
    "title": "tool",
    "description": "The main entrypoint to your MCP server",
    "path": "utils/100-tool",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Utils",
    "slug": "utils/100-tool",
    "slugFull": "/utils/100-tool"
  },
  {
    "title": "resource",
    "description": "The main entrypoint to your MCP server",
    "path": "utils/200-resource",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Utils",
    "slug": "utils/200-resource",
    "slugFull": "/utils/200-resource"
  },
  {
    "title": "prompt",
    "description": "The main entrypoint to your MCP server",
    "path": "utils/300-prompt",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Utils",
    "slug": "utils/300-prompt",
    "slugFull": "/utils/300-prompt"
  },
  {
    "title": "complete",
    "description": "The main entrypoint to your MCP server",
    "path": "utils/400-complete",
    "content": "<p>receive</p>",
    "raw": "receive",
    "toc": [],
    "section": "Utils",
    "slug": "utils/400-complete",
    "slugFull": "/utils/400-complete"
  }
]